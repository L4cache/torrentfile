{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TorrentFile Documentation The repo url is found on github at TorrentFile URL Commands Command Line Usage: \"\"\"Initialize Command Line Interface for torrentfile. usage: torrentfile --path /path/to/content [-o /path/to/output.torrent] [--piece-length n] [--private] [-t https://tracker.url/announce] [--v2] [--source x] [--announce-list tracker.url2 tracker.url3] [-h] \"\"\" Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. about.md # About page. LICENSE.md # License file. api.md # API Reference ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-torrentfile-documentation","text":"The repo url is found on github at TorrentFile URL","title":"Welcome to TorrentFile Documentation"},{"location":"#commands","text":"Command Line Usage: \"\"\"Initialize Command Line Interface for torrentfile. usage: torrentfile --path /path/to/content [-o /path/to/output.torrent] [--piece-length n] [--private] [-t https://tracker.url/announce] [--v2] [--source x] [--announce-list tracker.url2 tracker.url3] [-h] \"\"\"","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. about.md # About page. LICENSE.md # License file. api.md # API Reference ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"LICENSE/","text":"GNU Lesser General Public License Version 3, 29 June 2007 Copyright \u00a9 2007 Free Software Foundation, Inc. < http://fsf.org/ > Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below. 0. Additional Definitions As used herein, \u201cthis License\u201d refers to version 3 of the GNU Lesser General Public License, and the \u201cGNU GPL\u201d refers to version 3 of the GNU General Public License. \u201cThe Library\u201d refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \u201cApplication\u201d is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \u201cCombined Work\u201d is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \u201cLinked Version\u201d. The \u201cMinimal Corresponding Source\u201d for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \u201cCorresponding Application Code\u201d for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work. 1. Exception to Section 3 of the GNU GPL You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL. 2. Conveying Modified Versions If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy. 3. Object Code Incorporating Material from Library Header Files The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document. 4. Combined Works You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0) Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1) Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 4d0 , the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 4d1 , you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.) 5. Combined Libraries You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. 6. Revised Versions of the GNU Lesser General Public License The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \u201cor any later version\u201d applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"License"},{"location":"LICENSE/#gnu-lesser-general-public-license","text":"Version 3, 29 June 2007 Copyright \u00a9 2007 Free Software Foundation, Inc. < http://fsf.org/ > Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below.","title":"GNU Lesser General Public License"},{"location":"LICENSE/#0-additional-definitions","text":"As used herein, \u201cthis License\u201d refers to version 3 of the GNU Lesser General Public License, and the \u201cGNU GPL\u201d refers to version 3 of the GNU General Public License. \u201cThe Library\u201d refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \u201cApplication\u201d is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \u201cCombined Work\u201d is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \u201cLinked Version\u201d. The \u201cMinimal Corresponding Source\u201d for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \u201cCorresponding Application Code\u201d for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work.","title":"0. Additional Definitions"},{"location":"LICENSE/#1-exception-to-section-3-of-the-gnu-gpl","text":"You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL.","title":"1. Exception to Section 3 of the GNU GPL"},{"location":"LICENSE/#2-conveying-modified-versions","text":"If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy.","title":"2. Conveying Modified Versions"},{"location":"LICENSE/#3-object-code-incorporating-material-from-library-header-files","text":"The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document.","title":"3. Object Code Incorporating Material from Library Header Files"},{"location":"LICENSE/#4-combined-works","text":"You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0) Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1) Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 4d0 , the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 4d1 , you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.)","title":"4. Combined Works"},{"location":"LICENSE/#5-combined-libraries","text":"You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work.","title":"5. Combined Libraries"},{"location":"LICENSE/#6-revised-versions-of-the-gnu-lesser-general-public-license","text":"The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \u201cor any later version\u201d applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"6. Revised Versions of the GNU Lesser General Public License"},{"location":"about/","text":"Tamen sparsitque et ille et dabit conlegit Neque caerulaque iungi vidistis dotalia margine infelix Lorem markdownum vites finge verbis soror adfusique in moderato arduus. Nostraque feriat, altera mihique certe. Materna utque vesci signa arce Lycia silvisque vestro. Pontus fratris cum enim necemque deducitur pectus Pectora possis Armeniae Suis intus te Thetidi huc parari palmae Amans quid illam Ibidis bracchia et fertque talum Recentes flaventi geminas certe et augebat quoque Servare precor tristis manibus Echecli. Peto potes fluctibus omni consorti protinus oculisque viri non, est penna exstinctum monstra deterior pendent communiter aequorei fuit, multaque. Ante quaerenti mutato Adsuerant tecta utque questa, angues, consiliis moles credunt ipsa hoc vota certamen spectans, ilia ille. Quater victa . Maneas de monte montis vocem nubere erit Movebere ima at iubeas liventia fracta clipeum Meum mutataeque potuit Sua nec Ut Illa quae in cedere quaerit essem Incepto et ferre venit pollentibus ponti sequuntur Ortus ulmus, Achilleos, pectoraque quosque fatum cantibus aratri maxima! Illud cessura fortius facietque lacrimans nam, nec non gaudia Achivis, sine honorem. Athamanas tergo, fertilitas velut vix enim progenies frugum, fide diversa gravis! In tritis, cupiuntque caput. Qui et simul ipsaque, oro ultra exercere, laborum; ostendit Tonanti primaque cum ripam renuente . E omnibus petit Boum prensoque imagine bis at cupidine lacrimis torsit, glaeba una. Etiam sub confiteorque ignes concubitus deus custodemque quod et erant. Undis sola non ipsaque corpore; mea haeserat eligit ut est cum longa tabellae! Per an Sarpedonis tamen in regis siquis instituit, aetas requie illi sedes perque artus. In columbis mille labe quae cernitis subdita Lynceus. In haec salutem nullus sanguis, ubi proximus feror prisco deae, sintque discedens lyncum, modo tulit! Non vero de erat timendos et unda spectabat, huius querellae moratur flagratque . Velit ut umero in quoque neque atque recenti pallamque solebat, pudorem si agmina semper collo. Omina circumfususque nomine Aeneaeque suos nulla animosus rictus iunxit ustus, quam mearum tellus ulciscor, est.","title":"About"},{"location":"about/#tamen-sparsitque-et-ille-et-dabit-conlegit","text":"","title":"Tamen sparsitque et ille et dabit conlegit"},{"location":"about/#neque-caerulaque-iungi-vidistis-dotalia-margine-infelix","text":"Lorem markdownum vites finge verbis soror adfusique in moderato arduus. Nostraque feriat, altera mihique certe. Materna utque vesci signa arce Lycia silvisque vestro. Pontus fratris cum enim necemque deducitur pectus Pectora possis Armeniae Suis intus te Thetidi huc parari palmae Amans quid illam Ibidis bracchia et fertque talum","title":"Neque caerulaque iungi vidistis dotalia margine infelix"},{"location":"about/#recentes-flaventi-geminas-certe-et-augebat-quoque","text":"Servare precor tristis manibus Echecli. Peto potes fluctibus omni consorti protinus oculisque viri non, est penna exstinctum monstra deterior pendent communiter aequorei fuit, multaque.","title":"Recentes flaventi geminas certe et augebat quoque"},{"location":"about/#ante-quaerenti-mutato","text":"Adsuerant tecta utque questa, angues, consiliis moles credunt ipsa hoc vota certamen spectans, ilia ille. Quater victa . Maneas de monte montis vocem nubere erit Movebere ima at iubeas liventia fracta clipeum Meum mutataeque potuit Sua nec Ut Illa quae in cedere quaerit essem","title":"Ante quaerenti mutato"},{"location":"about/#incepto-et-ferre-venit-pollentibus-ponti-sequuntur","text":"Ortus ulmus, Achilleos, pectoraque quosque fatum cantibus aratri maxima! Illud cessura fortius facietque lacrimans nam, nec non gaudia Achivis, sine honorem. Athamanas tergo, fertilitas velut vix enim progenies frugum, fide diversa gravis! In tritis, cupiuntque caput. Qui et simul ipsaque, oro ultra exercere, laborum; ostendit Tonanti primaque cum ripam renuente .","title":"Incepto et ferre venit pollentibus ponti sequuntur"},{"location":"about/#e-omnibus-petit","text":"Boum prensoque imagine bis at cupidine lacrimis torsit, glaeba una. Etiam sub confiteorque ignes concubitus deus custodemque quod et erant. Undis sola non ipsaque corpore; mea haeserat eligit ut est cum longa tabellae! Per an Sarpedonis tamen in regis siquis instituit, aetas requie illi sedes perque artus. In columbis mille labe quae cernitis subdita Lynceus. In haec salutem nullus sanguis, ubi proximus feror prisco deae, sintque discedens lyncum, modo tulit! Non vero de erat timendos et unda spectabat, huius querellae moratur flagratque . Velit ut umero in quoque neque atque recenti pallamque solebat, pudorem si agmina semper collo. Omina circumfususque nomine Aeneaeque suos nulla animosus rictus iunxit ustus, quam mearum tellus ulciscor, est.","title":"E omnibus petit"},{"location":"api/","text":"API Reference Torrentfile can create Bittorrent metafiles for any content. Both Bittorrent v1 and v2 are fully supported. Also included is a torrent torrent file checker, which can verify a .torrent file is formated correctly as well as validate files and folders against metadata. !!! modules metafile: Creation/Validation of v1 .torrent files. metafile2: Creation/Validation of v2 .torrent files. torrentfile: torrentfiles Command Line Interface implementation. exceptions: Custom Exceptions used in package. utils: Utilities used throughout package. Main script entrypoint for creating .torrent files. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. !!! functions main_script: process command line arguments and run program. main () Initiate main function for CLI script. Source code in torrentfile\\torrentfile.py def main (): \"\"\"Initiate main function for CLI script.\"\"\" return main_script () main_script ( args = None ) Initialize Command Line Interface for torrentfile. !!! usage \"torrentfile --path /path/to/content [-o /path/to/output.torrent]\" --piece-length n [-t https://tracker.url/announce] [--v2] [--source x] [--announce-list tracker.url2 tracker.url3] [-h] Source code in torrentfile\\torrentfile.py def main_script ( args = None ): \"\"\"Initialize Command Line Interface for torrentfile. usage: torrentfile --path /path/to/content [-o /path/to/output.torrent] [--piece-length n] [--private] [-t https://tracker.url/announce] [--v2] [--source x] [--announce-list tracker.url2 tracker.url3] [-h] \"\"\" if not args : args = sys . argv [ 1 :] usage = \"\"\"torrentfile -v -h --path </path/to/content> [-o <output/path.torrent>] [--piece-length <n>] [--private] [-a https://tracker.url/announce] [--meta-version <n>] [--source <x>] [--announce-list <url2> <...>]\"\"\" d = \"Create .torrent files for Bittorrent v1 or v2.\" parser = ArgumentParser ( \"torrentfile\" , description = d , prefix_chars = \"-\" , usage = usage ) parser . add_argument ( \"--version\" , action = \"version\" , version = f \"torrentfile v { torrentfile . __version__ } \" , help = \"show program version and exit \\n \" , ) parser . add_argument ( \"-p\" , \"--path\" , action = \"store\" , dest = \"path\" , metavar = \"<path>\" , help = \"(required) path to torrent content\" , ) parser . add_argument ( \"-a\" , \"--announce\" , action = \"store\" , dest = \"announce\" , metavar = \"<url>\" , help = \"Primary tracker url.\" , ) parser . add_argument ( \"--piece-length\" , action = \"store\" , dest = \"piece_length\" , metavar = \"<n>\" , help = \"Transmit size for pieces of torrent content.\" , ) parser . add_argument ( \"--private\" , action = \"store_true\" , dest = \"private\" , help = \"For torrents distributed on private trackers.\" , ) parser . add_argument ( \"-o\" , \"--out\" , action = \"store\" , help = \"Specify path for .torrent file.\" , dest = \"outfile\" , metavar = \"<path>\" , ) parser . add_argument ( \"--meta-version\" , choices = [ \"1\" , \"2\" , \"3\" ], action = \"store\" , help = ( \"Specify the version of torrent metafile to create.\" \"1 = v1, 2 = v2, 3 = 1 & 2 Hybrid\" ), default = \"1\" , dest = \"meta_version\" , metavar = \"<n>\" , ) parser . add_argument ( \"--comment\" , action = \"store\" , dest = \"comment\" , metavar = \"<comment>\" , help = \"Include a comment in file metadata.\" , ) parser . add_argument ( \"--source\" , action = \"store\" , dest = \"source\" , metavar = \"<source>\" , help = \"ignore unless instructed otherwise\" , ) parser . add_argument ( \"--announce-list\" , action = \"extend\" , dest = \"announce_list\" , nargs = \"+\" , metavar = \"[<url>, ...]\" , help = \"Additional tracker url's\" , ) if not args : args = [ \"-h\" ] flags = parser . parse_args ( args ) if not flags . path : raise MissingPathError ( flags ) kwargs = { \"path\" : flags . path , \"announce\" : flags . announce , \"announce_list\" : flags . announce_list , \"piece_length\" : flags . piece_length , \"source\" : flags . source , \"private\" : flags . private , \"outfile\" : flags . outfile , \"comment\" : flags . comment , } print ( flags ) if flags . meta_version == \"2\" : torrent = TorrentFileV2 ( ** kwargs ) elif flags . meta_version == \"1\" : torrent = TorrentFile ( ** kwargs ) elif flags . meta_version == \"3\" : torrent = TorrentFileHybrid ( ** kwargs ) else : raise MissingPathError ( flags ) torrent . assemble () outfile , meta = torrent . write () parser . kwargs = kwargs parser . meta = meta parser . outfile = outfile return parser Creating and verfying Bittorrent v1 metafiles (.torrent). Notes From Bittorrent.org Documentation pages. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: announce The URL of the tracker. info This maps to a dictionary, with keys described below. All strings in a .torrent file that contains text must be UTF-8 encoded. info dictionary The name key maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length is almost always a power of two, most commonly 2 18 = 256 K (BitTorrent prior to version 3.2 uses 2 20 = 1 M as default). pieces maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. There is also a key length or a key files , but not both or neither. If length is present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. In the single file case, length maps to the length of the file in bytes. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: length - The length of the file, in bytes. path - A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name (a zero length list is an error case). In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory. Checker Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters: Name Type Description Default metafile ( str ): Path to \".torrent\" file. required location(`str`) Path where the content is located in filesystem. required Examples: metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\" location = \"/path/to/location\" os.path.exists(\"/path/to/location/content_file_or_dir\") Out: True checker = Checker(metafile, location) __init__ ( self , metafile , location ) special Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters: Name Type Description Default metafile ( str ): Path to \".torrent\" file. required location(`str`) Path where the content is located in filesystem. required Source code in torrentfile\\metafile.py def __init__ ( self , metafile , location ): \"\"\" Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Args: metafile:(`str`): Path to \".torrent\" file. location(`str`): Path where the content is located in filesystem. \"\"\" self . metafile = metafile self . location = location self . meta = {} self . info = {} self . total = 0 self . piece_length = None self . files = None self . name = None self . paths = [] self . fileinfo = {} self . status = 0 check ( self ) Check if all components work as expected. Source code in torrentfile\\metafile.py def check ( self ): \"\"\"Check if all components work as expected.\"\"\" self . decode_metafile () self . get_paths () status = self . check_path () return status check_path ( self ) Check if path exists and is the correct size and hash. Returns: Type Description `str` Indicating process has completed. Source code in torrentfile\\metafile.py def check_path ( self ): \"\"\" Check if path exists and is the correct size and hash. Returns: `str`: Indicating process has completed. \"\"\" if os . path . isfile ( self . location ): if os . path . basename ( self . location ) == self . name : paths = [ self . location ] else : paths = [ os . path . join ( self . location , i ) for i in self . paths ] return self . _check_path ( paths ) decode_metafile ( self ) Decode bencoded data inside .torrent file. Source code in torrentfile\\metafile.py def decode_metafile ( self ): \"\"\"Decode bencoded data inside .torrent file.\"\"\" fd = open ( self . metafile , \"rb\" ) . read () decoder = Bendecoder () terms = decoder . decode ( fd ) for key , val in terms . items (): self . meta [ key ] = val if key == \"info\" : for key1 , val1 in val . items (): self . info [ key1 ] = val1 self . piece_length = self . info [ \"piece length\" ] self . pieces = self . info [ \"pieces\" ] self . name = self . info [ \"name\" ] if \"length\" not in self . info : self . files = self . info [ \"files\" ] get_paths ( self ) Get list of paths from files list inside .torrent file. Source code in torrentfile\\metafile.py def get_paths ( self ): \"\"\"Get list of paths from files list inside .torrent file.\"\"\" if not self . files : self . paths . append ( self . name ) self . fileinfo [ self . name ] = self . info [ \"length\" ] else : for item in self . files : size = item [ \"length\" ] self . total += size path = os . path . join ( * item [ \"path\" ]) self . paths . append ( path ) self . fileinfo [ path ] = size return self . paths Feeder Construct the Feeder class. Seemlesly generate hashes of piece length data from filelist contents. Parameters: Name Type Description Default paths(`list`) List of files. required piece_length(`int`) Size of chuncks to split the data into. required total(`int`) Sum of all files in file list. required __init__ ( self , paths , piece_length , total ) special Construct the Feeder class. Generate hashes of piece length data from filelist contents. Parameters: Name Type Description Default paths(`list`) List of files. required piece_length(`int`) Size of chuncks to split the data into. required total(`int`) Sum of all files in file list. required Source code in torrentfile\\metafile.py def __init__ ( self , paths , piece_length , total ): \"\"\" Construct the Feeder class. Generate hashes of piece length data from filelist contents. Args: paths(`list`): List of files. piece_length(`int`): Size of chuncks to split the data into. total(`int`): Sum of all files in file list. \"\"\" self . piece_length = piece_length self . paths = paths self . total = total self . pieces = [] self . index = 0 self . current = open ( self . paths [ self . index ], \"rb\" ) self . iterator = self . leaves () __iter__ ( self ) special Iterate through feed pieces. Returns: Type Description `iter(self)` Iterator for leaves/hash pieces. Source code in torrentfile\\metafile.py def __iter__ ( self ): \"\"\" Iterate through feed pieces. Returns: `iter(self)`: Iterator for leaves/hash pieces. \"\"\" self . iterator = self . leaves () return self . iterator __next__ ( self ) special Return the next element from iterator. Returns: Type Description `bytes` Piece_length length pieces of data. Source code in torrentfile\\metafile.py def __next__ ( self ): \"\"\" Return the next element from iterator. Returns: `bytes`: Piece_length length pieces of data. \"\"\" return self . iterator . __next__ () handle_partial ( self , arr , partial ) Seemlessly move to next file for input data. Parameters: Name Type Description Default arr(`bytearray`) Incomplete piece containing partial data required partial(`int`) Size of incomplete piece_length required Returns: Type Description `bytes` SHA1 digest of the complete piece. Source code in torrentfile\\metafile.py def handle_partial ( self , arr , partial ): \"\"\" Seemlessly move to next file for input data. Args: arr(`bytearray`): Incomplete piece containing partial data partial(`int`): Size of incomplete piece_length Returns: `bytes`: SHA1 digest of the complete piece. \"\"\" while partial < self . piece_length : temp = bytearray ( self . piece_length - partial ) size = self . current . readinto ( temp ) acc = partial + size arr [ partial : acc ] = temp [: size ] partial += size if partial < self . piece_length : if not self . next_file (): return sha1 ( arr [: partial ]) . digest () # nosec return sha1 ( arr ) . digest () # nosec leaves ( self ) Generate piece-length pieces of data from input file list. Source code in torrentfile\\metafile.py def leaves ( self ): \"\"\"Generate piece-length pieces of data from input file list.\"\"\" while True : piece = bytearray ( self . piece_length ) size = self . current . readinto ( piece ) if size == 0 : if not self . next_file (): self . current . close () break elif size < self . piece_length : yield self . handle_partial ( piece , size ) else : yield sha1 ( piece ) . digest () # nosec next_file ( self ) Seemlessly transition to next file in file list. Source code in torrentfile\\metafile.py def next_file ( self ): \"\"\"Seemlessly transition to next file in file list.\"\"\" self . index += 1 if self . index < len ( self . paths ): self . current . close () self . current = open ( self . paths [ self . index ], \"rb\" ) return True return False total_pieces ( self ) Total size / piece length. Source code in torrentfile\\metafile.py def total_pieces ( self ): \"\"\"Total size / piece length.\"\"\" return math . ceil ( self . total // self . piece_length ) TorrentFile Class for creating Bittorrent meta files. Construct Torrentfile class instance object. Parameters: Name Type Description Default path(`str`) Path to torrent file or directory. required piece_length(`int`) Size of each piece of torrent data. required announce(`str`) Tracker URL. required announce_list(`str` or `list` Additional Tracker URLs. required private(`int`) 1 if private torrent else 0. required source(`str`) Source tracker. required comment(`str`) Comment string. required outfile(`str`) Path to write metfile to. required Returns: Type Description `obj` Instance of Metafile Class. __init__ ( self , path = None , announce = None , announce_list = None , private = False , source = None , piece_length = None , comment = None , outfile = None ) special Class for creating Bittorrent meta files from given parameters. Construct Torrentfile class instance object. Parameters: Name Type Description Default path('str') source path to torrent content. required announce('str') tracker URL. required announce_list('list') additional tracker URLS. required private('bool') used for private trackers. required comment('str') a comment. required outfile('str') target destination path. required source('str') used for private trackers. required Returns: Type Description `Torrentfile` Instance of Metafile Class. Source code in torrentfile\\metafile.py def __init__ ( self , path = None , announce = None , announce_list = None , private = False , source = None , piece_length = None , comment = None , outfile = None ): \"\"\" Class for creating Bittorrent meta files from given parameters. Construct *Torrentfile* class instance object. Args: path('str'): source path to torrent content. announce('str'): tracker URL. announce_list('list'): additional tracker URLS. private('bool'): used for private trackers. comment('str'): a comment. outfile('str'): target destination path. source('str'): used for private trackers. Returns: `Torrentfile`: Instance of Metafile Class. \"\"\" # fs path attributes. self . path = path self . name = os . path . basename ( path ) self . outfile = outfile # if `piece_length` is a `str` turn it into an `int`. if piece_length : self . piece_length = int ( piece_length ) else : self . piece_length = None self . announce = announce if announce : self . announce = announce else : self . announce = \"\" # If announce `list` is a `str` split it up. if isinstance ( announce_list , str ): self . announce_list = re . split ( r \"[\\s,]\" , announce_list ) else : self . announce_list = announce_list # for private trackers. self . private = private self . source = source # other less common flags. self . comment = comment self . meta = self . assemble () assemble ( self ) Assemble components of torrent metafile. Returns: Type Description `dict` metadata dictionary for torrent file Source code in torrentfile\\metafile.py def assemble ( self ): \"\"\" Assemble components of torrent metafile. Returns: `dict`: metadata dictionary for torrent file \"\"\" meta = { \"announce\" : self . announce } meta [ \"created by\" ] = \"torrentfile\" meta [ \"creation date\" ] = int ( dt . timestamp ( dt . now ())) meta [ \"info\" ] = self . _assemble_infodict () return meta write ( self , outfile = None ) Write assembled data to .torrent file. Parameters: Name Type Description Default outfile (Default value = None) None Returns: Type Description `tuple` Path to output file, Pre-encoded metadata. Source code in torrentfile\\metafile.py def write ( self , outfile = None ): \"\"\" Write assembled data to .torrent file. Args: outfile: (Default value = None) Returns: `tuple`: Path to output file, Pre-encoded metadata. \"\"\" encoder = Benencoder () data = encoder . encode ( self . meta ) if not outfile : if not self . outfile : self . outfile = self . meta [ \"info\" ][ \"name\" ] + \".torrent\" else : self . outfile = outfile with open ( self . outfile , \"wb\" ) as fd : fd . write ( data ) return ( self . outfile , self . meta ) Metafile procedures for Bittorrent v2. This module metafile2 contains classes and functions related to constructing .torrent files using Bittorrent v2 Protocol !!! classes TorrentFileV2 : construct .torrent files using provided data. FileHash : Calculates leaf hashes and root hashes for torrent contents. !!! constants BLOCK_SIZE( int ): size of leaf hashes for merkle tree. Notes Implementation details for Bittorrent Protocol v2. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: \"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' in this context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On most platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require valid UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in the same order as in the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key. File tree layout Example: {info: {file tree: {dir1: {dir2: {fileA.txt: { \"\": {length: <length of file in bytes (integer)>, pieces root: <optional, merkle tree root (string)>} }, fileB.txt: { \"\": {length: `int`, pieces root: `string`} }} } } } } Note that identical files always result in the same root hash. All strings in a .torrent file defined by this BEP that contain human-readable text are UTF-8 encoded. Single-file torrent: \"file tree\": {name.ext: {\"\": {length: ...}}} Multiple files rooted in a single directory: python: \"file tree\": {dir: { nameA.ext: {\"\": {length: ...}}, nameB.ext: {\"\": {length: ...}}}} FileHash Calculate and store hash information for specific file. Parameters: Name Type Description Default path(`str`) Absolute path to file. required piece_length(`int`) Size of each metfile piece. required Returns: Type Description `obj` Instance of FileHash. __init__ ( self , path , piece_length ) special Calculate and store hash information for specific file. Parameters: Name Type Description Default path(`str`) Absolute path to file. required piece_length(`int`) Size of each metfile piece. required Returns: Type Description `obj` Instance of FileHash. Source code in torrentfile\\metafile2.py def __init__ ( self , path , piece_length ): \"\"\" Calculate and store hash information for specific file. Args: path(`str`): Absolute path to file. piece_length(`int`): Size of each metfile piece. Returns: `obj`: Instance of FileHash. \"\"\" self . path = path self . root_hash = None self . piece_layers = None self . layer_hashes = [] self . piece_length = piece_length self . piece_blocks = piece_length // BLOCK_SIZE with open ( self . path , \"rb\" ) as fd : self . _process_file ( fd ) TorrentFileV2 Class for creating Bittorrent meta v2 files. Parameters: Name Type Description Default path(`str`) Path to torrent file or directory. required piece_length(`int`) Size of each piece of torrent data. required announce(`str`) Tracker URL. required announce_list('list`) List of additional trackers. required private(`int`) 1 if private torrent else 0. required source(`str`) Source tracker. required comment(`str`) Comment string. required outfile(`str`) Path to write metfile to. required Returns: Type Description `obj` Instance of Metafile Class. __init__ ( self , path = None , source = None , outfile = None , announce = None , announce_list = None , comment = None , private = None , piece_length = None ) special Construct TorrentFileV2 Class instance from given parameters. Parameters: Name Type Description Default path(`str`) Path to torrent file or directory. required piece_length(`int`) Size of each piece of torrent data. required announce(`str`) Tracker URL. required announce_list('list`) List of additional trackers. required private(`int`) 1 if private torrent else 0. required source(`str`) Source tracker. required comment(`str`) Comment string. required outfile(`str`) Path to write metfile to. required Returns: Type Description `obj` Instance of Metafile Class. Source code in torrentfile\\metafile2.py def __init__ ( self , path = None , source = None , outfile = None , announce = None , announce_list = None , comment = None , private = None , piece_length = None ,): \"\"\" Construct `TorrentFileV2` Class instance from given parameters. Args: path(`str`): Path to torrent file or directory. piece_length(`int`): Size of each piece of torrent data. announce(`str`): Tracker URL. announce_list('list`): List of additional trackers. private(`int`): 1 if private torrent else 0. source(`str`): Source tracker. comment(`str`): Comment string. outfile(`str`): Path to write metfile to. Returns: `obj`: Instance of Metafile Class. \"\"\" self . name = os . path . basename ( path ) self . path = path self . comment = comment self . piece_length = piece_length self . private = private self . source = source self . announce = announce self . announce_list = announce_list self . outfile = outfile self . hashes = [] self . piece_layers = {} self . meta = self . assemble () assemble ( self ) Assemble then return the meta dictionary for encoding. Returns: Type Description meta(`dict`) Metainformation about the torrent. Source code in torrentfile\\metafile2.py def assemble ( self ): \"\"\" Assemble then return the meta dictionary for encoding. Returns: meta(`dict`): Metainformation about the torrent. \"\"\" # if no tracker url was provided, place dummy string in its place # which can be later replaced by some Bittorrent clients if not self . piece_length : self . piece_length = path_piece_length ( self . path ) elif isinstance ( self . piece_length , str ): self . piece_length = int ( self . piece_length ) if self . announce : meta = { \"announce\" : self . announce } else : meta = { \"announce\" : \"\" } meta [ \"created by\" ] = \"torrentfile\" meta [ \"creation date\" ] = int ( datetime . timestamp ( datetime . now ())) # assemble info dictionary and assign it to info key in meta meta [ \"info\" ] = self . _assemble_infodict () for hasher in self . hashes : if hasher . piece_layers : self . piece_layers [ hasher . root_hash ] = hasher . piece_layers meta [ \"piece layers\" ] = self . piece_layers return meta write ( self , outfile = None ) Write assembled data to .torrent file. Parameters: Name Type Description Default outfile(`str`) Path to save location. required Returns: Type Description `bytes` Data writtend to .torrent file. Source code in torrentfile\\metafile2.py def write ( self , outfile = None ): \"\"\" Write assembled data to .torrent file. Args: outfile(`str`): Path to save location. Returns: `bytes`: Data writtend to .torrent file. \"\"\" encoder = Benencoder () self . data = encoder . encode ( self . meta ) if outfile : self . outfile = outfile elif not self . outfile : self . outfile = self . meta [ \"info\" ][ \"name\" ] + \".torrent\" with open ( self . outfile , \"wb\" ) as fd : fd . write ( self . data ) return self . outfile , self . meta merkle_root ( pieces ) Generate root hash of a merkle Tree with input as leaves. Source code in torrentfile\\metafile2.py def merkle_root ( pieces ): \"\"\"Generate root hash of a merkle Tree with input as leaves.\"\"\" while len ( pieces ) > 1 : pieces = [ sha256 ( x + y ) . digest () for x , y in zip ( * [ iter ( pieces )] * 2 )] return pieces [ 0 ] Classes and procedures for making Bittorrent metafiles. Creating .torrent files that support both Bittorrent v1 & v2 metadata structure and hashes simultaneously. This module was partly influenced by \"bep_0052_torrent_creator\". !!! classes TorrentFileHybrid Hasher Hasher Calculate hashes for Hybrid torrentfile. Parameters: Name Type Description Default path(`str` or pathlike path to target file. required piece_length(`int`) piece length for data chunks. required __init__ ( self , path , piece_length ) special Construct Hasher class instances for each file in torrent. Calculates sha1 and sha256 hashes for each version # nosec of the Bittorrent protocols meta files. Parameters: Name Type Description Default path `str` Path to target file. required piece_length `int` Meta file piece length. required Source code in torrentfile\\hybrid.py def __init__ ( self , path , piece_length ): \"\"\" Construct Hasher class instances for each file in torrent. Calculates sha1 and sha256 hashes for each version # nosec of the Bittorrent protocols meta files. Args: path (`str`): Path to target file. piece_length (`int`): Meta file piece length. \"\"\" self . path = path self . size = 0 self . hashv1 = [] self . hashv2 = [] self . padding_hash = None self . padding_file = None num_blocks = piece_length // BLOCK_SIZE with open ( path , \"rb\" ) as data : block = bytearray ( BLOCK_SIZE ) while True : residue = piece_length v2blocks = [] v1blocks = bytearray () for _ in range ( num_blocks ): size = data . readinto ( block ) if size == 0 : break self . size += size residue -= size v2blocks . append ( sha256 ( block [: size ]) . digest ()) v1blocks . extend ( block [: size ]) if len ( v2blocks ) == 0 : break if len ( v2blocks ) != num_blocks : if not self . hashv2 : leaves = 1 << ( len ( v2blocks ) - 1 ) . bit_length () else : leaves = num_blocks needed = leaves - len ( v2blocks ) v2blocks . extend ([ bytes ( 32 ) for _ in range ( needed )]) self . _apply_padding ( residue ) self . hashv2 . append ( merkle_root ( v2blocks )) self . hashv1 . append ( sha1 ( v1blocks ) . digest ()) # nosec if self . size > 0 : layer_hashes = self . hashv2 if len ( self . hashv2 ) > 1 : self . hashv2 = b \"\" . join ( self . hashv2 ) pad_piece = merkle_root ([ bytes ( 32 )] * num_blocks ) power_two = 1 << ( len ( layer_hashes ) - 1 ) . bit_length () remainder = power_two - len ( layer_hashes ) layer_hashes . extend ( pad_piece for _ in range ( remainder )) self . _apply_padding (( BLOCK_SIZE * num_blocks ) * remainder ) self . root = merkle_root ( layer_hashes ) TorrentFileHybrid Create Bittorrent v1 v2 hybrid metafiles. __init__ ( self , path = None , announce = None , announce_list = None , comment = None , source = None , outfile = None , private = None , piece_length = None ) special Construct the Hybrid torrent meta file with provided parameters. Parameters: Name Type Description Default path `str` path to torrentfile target. None announce `str` Tracker URL. None announce_list `list` Additional tracker URLs. None comment `str` Some comment. None source `str` Used for private trackers. None outfile `str` target path to write output. None private `bool` Used for private trackers. None piece_length `int` torrentfile data piece length. None Source code in torrentfile\\hybrid.py def __init__ ( self , path = None , announce = None , announce_list = None , comment = None , source = None , outfile = None , private = None , piece_length = None ): \"\"\" Construct the Hybrid torrent meta file with provided parameters. Args: path (`str`): path to torrentfile target. announce (`str`): Tracker URL. announce_list (`list`): Additional tracker URLs. comment (`str`): Some comment. source (`str`): Used for private trackers. outfile (`str`): target path to write output. private (`bool`): Used for private trackers. piece_length (`int`): torrentfile data piece length. \"\"\" self . path = path self . name = os . path . basename ( path ) self . announce = announce self . announce_list = announce_list self . comment = comment self . source = source self . private = private self . piece_length = piece_length self . outfile = outfile self . piece_layers = [] self . pieces = [] self . files = [] self . residuals = None self . meta = self . assemble () assemble ( self ) Assemble the parts of the torrentfile into meta dictionary. Source code in torrentfile\\hybrid.py def assemble ( self ): \"\"\"Assemble the parts of the torrentfile into meta dictionary.\"\"\" if not self . announce : meta = { \"announce\" : \"\" } else : meta = { \"announce\" : self . announce } meta [ \"created by\" ] = \"torrentfile\" meta [ \"creation date\" ] = int ( datetime . timestamp ( datetime . now ())) meta [ \"info\" ] = self . _assemble_infodict () meta [ \"pieces\" ] = self . pieces meta [ \"piece_layers\" ] = self . piece_layers return meta write ( self , outfile = None ) Create a Hybrid metainfo dictionary. Parameters: Name Type Description Default outfile(`str` or `path-like` where to write file to. required Source code in torrentfile\\hybrid.py def write ( self , outfile = None ): \"\"\" Create a Hybrid metainfo dictionary. Args: outfile(`str` or `path-like`): where to write file to. \"\"\" if outfile : self . outfile = outfile elif not self . outfile : self . outfile = os . path . basename ( self . path ) + \".torrent\" encoder = Benencoder () data = encoder . encode ( self . meta ) with open ( self . outfile , \"wb\" ) as fd : fd . write ( data ) return ( self . outfile , self . meta ) merkle_root ( blocks ) Calculate the merkle root for a seq of sha256 hash digests. Source code in torrentfile\\hybrid.py def merkle_root ( blocks ): \"\"\"Calculate the merkle root for a seq of sha256 hash digests.\"\"\" while len ( blocks ) > 1 : blocks = [ sha256 ( l + r ) . digest () for l , r in zip ( * [ iter ( blocks )] * 2 )] return blocks [ 0 ] Utility functions and classes used throughout package. Classes: Bendecoder: Decoder for bencode data. Benencoder: Encode data to bencode data. Functions: get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory. Bendecoder Bendecoder class contains all decode and convenience methods. Initialize instance with optional pre compiled data. Parameters: Name Type Description Default data(`bytes`) Target data for decoding. required __init__ ( self , data = None ) special Bendecoder class contains all decode and convenience methods. Initialize instance with optional pre compiled data. Parameters: Name Type Description Default data(`bytes`) Target data for decoding. required Source code in torrentfile\\utils.py def __init__ ( self , data = None ): \"\"\"Bendecoder class contains all decode and convenience methods. Initialize instance with optional pre compiled data. Args: data(`bytes`): Target data for decoding. \"\"\" self . data = data decode ( self , bits = None ) Decode bencoded data. Parameters: Name Type Description Default bits(`bytes`) Bencoded data for decoding. required Returns: Type Description `any` The decoded data. Source code in torrentfile\\utils.py def decode ( self , bits = None ): \"\"\"Decode bencoded data. Args: bits(`bytes`): Bencoded data for decoding. Returns: `any`: The decoded data. \"\"\" bits = bits if bits is not None else self . data try : data , _ = self . _decode ( bits ) except AttributeError as excpt : raise BendecodingError ( bits ) from excpt return data Benencoder Encode collection of methods for Bencoding data. Initialize Benencoder insance with optional pre compiled data. __init__ ( self , data = None ) special Initialize Benencoder insance with optional pre compiled data. Parameters: Name Type Description Default data(`any`, optional Target data for encoding. Defaults to None. required Source code in torrentfile\\utils.py def __init__ ( self , data = None ): \"\"\" Initialize Benencoder insance with optional pre compiled data. Args: data(`any`, optional): Target data for encoding. Defaults to None. \"\"\" self . data = data encode ( self , val = None ) Encode data with bencode encoding. Parameters: Name Type Description Default val(`any`) data to be encoded. required Returns: Type Description `bytes` Decoded data. Source code in torrentfile\\utils.py def encode ( self , val = None ): \"\"\"Encode data with bencode encoding. Args: val(`any`): data to be encoded. Returns: `bytes`: Decoded data. \"\"\" val = val if val is not None else self . data if isinstance ( val , str ): return self . _encode_str ( val ) if hasattr ( val , \"hex\" ): return self . _encode_bytes ( val ) if isinstance ( val , int ): return self . _encode_int ( val ) if isinstance ( val , list ): return self . _encode_list ( val ) if isinstance ( val , dict ): return self . _encode_dict ( val ) if isinstance ( val , bool ): return 1 if val else 0 raise BenencodingError ( val ) get_file_list ( path , sort = False ) Search directory tree for files. Parameters: Name Type Description Default path(`str`) Path to file or directory base required sort(`bool`) Return list sorted. Defaults to False. required Returns: Type Description `list` All file paths within directory tree. Source code in torrentfile\\utils.py def get_file_list ( path , sort = False ): \"\"\" Search directory tree for files. Args: path(`str`): Path to file or directory base sort(`bool`): Return list sorted. Defaults to False. Returns: `list`: All file paths within directory tree. \"\"\" if os . path . isfile ( path ): return [ path ] # put all files into filelist within directory files = [] filelist = os . listdir ( path ) # optional canonical sort of filelist if sort : filelist . sort ( key = str . lower ) # recursive for all folders for item in filelist : full = os . path . join ( path , item ) files . extend ( get_file_list ( full , sort = sort )) return files get_piece_length ( size ) Calculate the ideal piece length for bittorrent data. Parameters: Name Type Description Default size(`int`) Total bits of all files incluided in .torrent file. required Returns: Type Description `int` Ideal peace length calculated from the size arguement. Source code in torrentfile\\utils.py def get_piece_length ( size ): \"\"\" Calculate the ideal piece length for bittorrent data. Args: size(`int`): Total bits of all files incluided in .torrent file. Returns: `int`: Ideal peace length calculated from the size arguement. \"\"\" exp = 14 while size / ( 2 ** exp ) > 200 and exp < 23 : exp += 1 return 2 ** exp path_piece_length ( path ) Calculate piece length for input path and contents. Parameters: Name Type Description Default path(`str`) The absolute path to directory and contents. required Returns: Type Description piece_length(`int`) The size of pieces of torrent content. Source code in torrentfile\\utils.py def path_piece_length ( path ): \"\"\" Calculate piece length for input path and contents. Args: path(`str`): The absolute path to directory and contents. Returns: piece_length(`int`): The size of pieces of torrent content. \"\"\" psize = path_size ( path ) return get_piece_length ( psize ) path_size ( path ) Calculate sum of all filesizes within directory. path( str ): The path to start calculating from. Returns: Type Description `int` Total sum in bytes. Source code in torrentfile\\utils.py def path_size ( path ): \"\"\" Calculate sum of all filesizes within directory. Args: path(`str`): The path to start calculating from. Returns: `int`: Total sum in bytes. \"\"\" size = 0 if os . path . isfile ( path ): return os . path . getsize ( path ) # recursive sum for all files in folder if os . path . isdir ( path ): for name in os . listdir ( path ): fullpath = os . path . join ( path , name ) size += path_size ( fullpath ) return size path_stat ( path ) Calculate directory statistics. Parameters: Name Type Description Default path(`str`) The path to start calculating from. required Returns: Type Description filelist(`list`) List of all files contained in Directory size( int ): Total sum of bytes from all contents of dir piece_length( int ): The size of pieces of the torrent contents. Source code in torrentfile\\utils.py def path_stat ( path ): \"\"\" Calculate directory statistics. Args: path(`str`): The path to start calculating from. Returns: filelist(`list`): List of all files contained in Directory size(`int`): Total sum of bytes from all contents of dir piece_length(`int`): The size of pieces of the torrent contents. \"\"\" filelist , size = _dir_files_sizes ( path ) piece_length = get_piece_length ( size ) return ( filelist , size , piece_length ) sortfiles ( path ) Generate files one at a time in sorted order. Parameters: Name Type Description Default path(`str`) Directory path to get file list from. required Yields: ( str ) Next path in filelist. Source code in torrentfile\\utils.py def sortfiles ( path ): \"\"\" Generate files one at a time in sorted order. Args: path(`str`): Directory path to get file list from. Yields: (`str`) Next path in filelist. \"\"\" filelist = sorted ( os . listdir ( path ), key = str . lower ) for item in filelist : yield ( item , os . path . join ( path , item )) Torrentfile testing modules. context Context Functions used throughout testing suite. fill_file ( path , exp ) Fill file with random bytes. Source code in tests\\context.py def fill_file ( path , exp ): \"\"\"Fill file with random bytes.\"\"\" bits = seq () . encode ( \"utf8\" ) bitlen = len ( bits ) filesize = 0 with open ( path , \"wb\" ) as fd : while filesize + bitlen < 2 ** exp : fd . write ( bits ) filesize += bitlen diff = 2 ** exp - filesize fd . write ( bits [: diff + 1 ]) fill_folder ( folder ) Fill temporary folder with meaningless data. Source code in tests\\context.py def fill_folder ( folder ): \"\"\"Fill temporary folder with meaningless data.\"\"\" files = { \"file1.bin\" : 25 , \"file2.bin\" : 26 } if not os . path . exists ( folder ): os . mkdir ( folder ) for k , v in files . items (): path = os . path . join ( folder , k ) fill_file ( path , v ) rmpath ( path ) Recursively remove path. Source code in tests\\context.py def rmpath ( path ): \"\"\"Recursively remove path.\"\"\" if not os . path . exists ( path ): return if os . path . isdir ( path ): shutil . rmtree ( path ) else : os . remove ( path ) rmpaths ( paths ) Recursively remove all paths. Source code in tests\\context.py def rmpaths ( paths ): \"\"\"Recursively remove all paths.\"\"\" for path in paths : rmpath ( path ) seq () Generate random sequence of characters. Source code in tests\\context.py def seq (): \"\"\"Generate random sequence of characters.\"\"\" text = string . printable + string . punctuation + string . hexdigits random . shuffle ( list ( text )) return \"\" . join ( text ) sizedfile ( num = 28 ) Generate a specifically sized file with meaningless data. Source code in tests\\context.py def sizedfile ( num = 28 ): \"\"\"Generate a specifically sized file with meaningless data.\"\"\" path = os . path . join ( TD , \"tempfile.bin\" ) fill_file ( path , num ) return path tempdir () Generate temporary directory filled with meaningless data. Source code in tests\\context.py def tempdir (): \"\"\"Generate temporary directory filled with meaningless data.\"\"\" tdir = os . path . join ( TD , \"tempdir\" ) tdir_1 = os . path . join ( tdir , \"directory1\" ) for folder in [ tdir , tdir_1 ]: rmpath ( folder ) os . mkdir ( folder ) fill_folder ( folder ) return tdir tempfile () Generate temporary file filled with meaningless data. Source code in tests\\context.py def tempfile (): \"\"\"Generate temporary file filled with meaningless data.\"\"\" path = os . path . join ( TD , \"tempfile.bin\" ) fill_file ( path , 28 ) return path test_cli Test CLI script functionality. tdir () Generate temp testing directory. Source code in tests\\test_cli.py @pytest . fixture ( scope = \"module\" ) def tdir (): \"\"\"Generate temp testing directory.\"\"\" directory = tempdir () yield directory rmpath ( directory ) test_cli_args_dir ( tdir ) Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_dir ( tdir ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"--path\" , tdir ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile ) test_cli_args_dir_v2 ( tdir ) Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_dir_v2 ( tdir ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"-p\" , tdir , \"--meta-version\" , \"2\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile ) test_cli_args_dir_v3 ( tdir ) Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_dir_v3 ( tdir ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"-p\" , tdir , \"--meta-version\" , \"3\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile ) test_cli_args_file ( tfile ) Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_file ( tfile ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"--path\" , tfile ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile ) test_cli_args_file_v2 ( tfile ) Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_file_v2 ( tfile ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"-p\" , tfile , \"--meta-version\" , \"2\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile ) test_cli_args_file_v3 ( tfile ) Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_file_v3 ( tfile ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"-p\" , tfile , \"--meta-version\" , \"3\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile ) test_cli_no_args () Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_no_args (): \"\"\"Test CLI script with specific arguments.\"\"\" sys . argv = [ sys . argv [ 0 ]] try : main () except SystemExit : assert True # nosec test_cli_no_args_v2 () Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_no_args_v2 (): \"\"\"Test CLI script with specific arguments.\"\"\" try : args = [ \"--meta-version\" , \"2\" ] sys . argv = [ sys . argv [ 0 ]] + args assert main () # nosec except MissingPathError : assert True # nosec test_cli_with_all_args_dir ( tdir ) Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_with_all_args_dir ( tdir ): \"\"\"Test CLI script with specific arguments.\"\"\" sys . argv = [ \"torrentfile\" , \"-p\" , tdir , \"--meta-version\" , \"3\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 14 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main () assert os . path . exists ( parser . outfile ) # nosec test_cli_with_all_args_file ( tfile ) Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_with_all_args_file ( tfile ): \"\"\"Test CLI script with specific arguments.\"\"\" sys . argv = [ \"torrentfile\" , \"-p\" , tfile , \"--meta-version\" , \"2\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 14 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main () assert os . path . exists ( parser . outfile ) # nosec tfile () Generate temp testing file. Source code in tests\\test_cli.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Generate temp testing file.\"\"\" temp = tempfile () yield temp rmpath ( temp ) test_context Testing operation and coverage for context module in tests directory. test_fill_file () Test fill_file function. Source code in tests\\test_context.py def test_fill_file (): \"\"\"Test fill_file function.\"\"\" path = os . path . join ( TD , \"filledfile.bin\" ) fill_file ( path , 16 ) assert os . path . exists ( path ) # nosec assert os . path . getsize ( path ) >= 2 ** 16 # nosec rmpath ( path ) test_fill_folder () Test fill_folder function. Source code in tests\\test_context.py def test_fill_folder (): \"\"\"Test fill_folder function.\"\"\" folder = os . path . join ( TD , \"filledfolder\" ) fill_folder ( folder ) assert os . path . exists ( folder ) # nosec rmpath ( folder ) test_rmpath_rmpaths () Test rmpath function and rmpaths function. Source code in tests\\test_context.py @pytest . mark . last def test_rmpath_rmpaths (): \"\"\"Test rmpath function and rmpaths function.\"\"\" dirpath = tempdir () filepath = tempfile () sizedpath = sizedfile ( 16 ) fillfile = os . path . join ( TD , \"filledfile.bin\" ) fillfolder = os . path . join ( TD , \"filledfolder\" ) fill_file ( fillfile , 16 ) fill_folder ( fillfolder ) rmpath ( fillfile ) assert not os . path . exists ( fillfile ) # nosec pathlist = [ sizedpath , dirpath , filepath , fillfolder ] rmpaths ( pathlist ) for path in pathlist : assert not os . path . exists ( path ) # nosec test_seq () Test seq function for random string output. Source code in tests\\test_context.py def test_seq (): \"\"\"Test seq function for random string output.\"\"\" output = seq () assert len ([ i for i in output if i in string . printable ]) > 1 # nosec test_sizedfile () Test tempdir function. Source code in tests\\test_context.py def test_sizedfile (): \"\"\"Test tempdir function.\"\"\" path = sizedfile ( 16 ) assert os . path . exists ( path ) # nosec assert os . path . getsize ( path ) > 2 ** 16 # nosec rmpath ( path ) test_tempdir () Test tempdir function. Source code in tests\\test_context.py def test_tempdir (): \"\"\"Test tempdir function.\"\"\" dirpath = tempdir () assert os . path . exists ( dirpath ) # nosec rmpath ( dirpath ) test_tempfile () Test tempfile function. Source code in tests\\test_context.py def test_tempfile (): \"\"\"Test tempfile function.\"\"\" filepath = tempfile () assert os . path . exists ( filepath ) # nosec rmpath ( filepath ) test_main Test main module functionality. test_class_annlist_v2 ( tfile ) Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : ( \"https://tracker2/announce\" \" https://tracker3/announce\" \" https://tracker4/announce\" ), } torfile = TorrentFileV2 ( ** kwargs ) meta = torfile . assemble () url = \"https://tracker2/announce\" assert url in meta [ \"info\" ][ \"announce list\" ] # nosec test_class_list_annlist ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : [ \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torfile = TorrentFile ( ** kwargs ) meta = torfile . assemble () url = \"https://tracker2/announce\" assert url in meta [ \"info\" ][ \"announce list\" ] # nosec test_class_list_annlist_v2 ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : [ \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torfile = TorrentFileV2 ( ** kwargs ) meta = torfile . assemble () url = \"https://tracker2/announce\" assert url in meta [ \"info\" ][ \"announce list\" ] # nosec test_class_tuple_annlist ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : ( \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torfile = TorrentFile ( ** kwargs ) meta = torfile . assemble () url = \"https://tracker2/announce\" assert url in meta [ \"info\" ][ \"announce list\" ] # nosec test_class_tuple_annlist_v2 ( tfile ) Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : ( \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torfile = TorrentFileV2 ( ** kwargs ) meta = torfile . assemble () url = \"https://tracker2/announce\" assert url in meta [ \"info\" ][ \"announce list\" ] # nosec test_class_with_annlist ( tfile ) Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_with_annlist ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : ( \"https://tracker2/announce\" \" https://tracker3/announce\" \" https://tracker4/announce\" ), } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker2/announce\" assert url in torrent . meta [ \"info\" ][ \"announce list\" ] # nosec test_main () Test maine . Source code in tests\\test_main.py def test_main (): \"\"\"Test __maine__.\"\"\" assert entry . __doc__ # nosec test_main_annlist_single ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_single_v1 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v1 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"--meta-version\" , \"1\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_single_v2 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"--meta-version\" , \"2\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_single_v3 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"--meta-version\" , \"3\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_v2 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"2\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile ) test_main_annlist_v3 ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"3\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile ) test_main_announce_list ( tfile ) Test main function with announce list flag. Source code in tests\\test_main.py def test_main_announce_list ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile ) tfile () Create fixture for tests. Source code in tests\\test_main.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Create fixture for tests.\"\"\" args = [ \"torrentfile\" , \"--private\" , \"--announce\" , \"https://tracker1.to/announce\" , \"--source\" , \"TFile\" , ] t_file = tempfile () yield args , t_file rmpath ( t_file ) test_meta Test metafile generators functionality. maketorrent ( args , ver2 = False ) Torrent making factory. Source code in tests\\test_meta.py def maketorrent ( args , ver2 = False ): \"\"\"Torrent making factory.\"\"\" if ver2 : torrent = TorrentFileV2 ( ** args ) else : torrent = TorrentFile ( ** args ) torrent . assemble () return torrent . write () metav1d ( tdir ) Return generated metadata v1 for directory. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def metav1d ( tdir ): \"\"\"Return generated metadata v1 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args ) yield outfile , meta rmpaths ([ tdir , outfile ]) metav1f ( tfile ) Return generated metadata v1 for file. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def metav1f ( tfile ): \"\"\"Return generated metadata v1 for file.\"\"\" args = { \"private\" : True , \"path\" : tfile , \"announce\" : \"http://announce.com/announce\" , } outfile , meta = maketorrent ( args ) yield outfile , meta rmpaths ([ tfile , outfile ]) metav2d ( tdir ) Return generated metadata v2 for directory. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def metav2d ( tdir ): \"\"\"Return generated metadata v2 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args , ver2 = True ) yield outfile , meta rmpaths ([ tdir , outfile ]) metav2f ( tfile ) Return generated metadata v2 for file. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def metav2f ( tfile ): \"\"\"Return generated metadata v2 for file.\"\"\" args = { \"private\" : True , \"path\" : tfile , \"announce\" : \"http://announce.com/announce\" , } outfile , meta = maketorrent ( args , ver2 = True ) yield outfile , meta rmpaths ([ tfile , outfile ]) tdir () Return temp directory. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def tdir (): \"\"\"Return temp directory.\"\"\" return tempdir () tdirmeta ( tdir ) Test metadata. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def tdirmeta ( tdir ): \"\"\"Test metadata.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , } outfile , _ = maketorrent ( args ) yield outfile , tdir rmpaths ([ tdir , outfile ]) test_metafile_checker_v1_dir ( tdirmeta ) Test metadata. Source code in tests\\test_meta.py def test_metafile_checker_v1_dir ( tdirmeta ): \"\"\"Test metadata.\"\"\" outfile , tdir = tdirmeta checker = Checker ( outfile , tdir ) status = checker . check () assert status == \"100%\" # nosec test_metafile_checker_v1_file ( tfilemeta ) Test metadata. Source code in tests\\test_meta.py def test_metafile_checker_v1_file ( tfilemeta ): \"\"\"Test metadata.\"\"\" outfile , tfile = tfilemeta checker = Checker ( outfile , tfile ) status = checker . check () assert status == \"100%\" # nosec test_v1_info_keys_dir ( metav1d ) Test metadata. Source code in tests\\test_meta.py def test_v1_info_keys_dir ( metav1d ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1d for key in [ \"piece length\" , \"pieces\" , \"name\" , \"private\" , \"source\" , \"comment\" , ]: assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v1_info_keys_file ( metav1f ) Test metadata. Source code in tests\\test_meta.py def test_v1_info_keys_file ( metav1f ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1f for key in [ \"length\" , \"piece length\" , \"pieces\" , \"name\" , \"private\" , ]: assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v1_meta_keys ( metav1f ) Test metadata. Source code in tests\\test_meta.py def test_v1_meta_keys ( metav1f ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1f for key in [ \"announce\" , \"info\" , \"creation date\" ]: assert key in meta # nosec assert os . path . exists ( outfile ) # nosec test_v2_info_keys_dir ( metav2d ) Test metadata. Source code in tests\\test_meta.py def test_v2_info_keys_dir ( metav2d ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2d for key in [ \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , \"source\" , \"comment\" , ]: assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v2_info_keys_file ( metav2f ) Test metadata. Source code in tests\\test_meta.py def test_v2_info_keys_file ( metav2f ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2f for key in [ \"length\" , \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , ]: assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec test_v2_meta_keys ( metav2f ) Test metadata. Source code in tests\\test_meta.py def test_v2_meta_keys ( metav2f ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2f for key in [ \"announce\" , \"info\" , \"piece layers\" , \"creation date\" ]: assert key in meta # nosec assert os . path . exists ( outfile ) # nosec tfile () Return temp file. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Return temp file.\"\"\" return tempfile () tfilemeta ( tfile ) Test metadata. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def tfilemeta ( tfile ): \"\"\"Test metadata.\"\"\" args = { \"private\" : True , \"path\" : tfile , \"announce\" : \"http://announce.com/announce\" , } outfile , _ = maketorrent ( args ) yield outfile , tfile rmpaths ([ tfile , outfile ]) test_torrentfile Testing functions for torrentfile module. tdir () Return temporary directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def tdir (): \"\"\"Return temporary directory.\"\"\" folder = tempdir () args = { \"path\" : folder , \"announce\" : \"https://tracker.com/announce\" } yield ( folder , args ) rmpath ( folder ) test_exception_decoding_error () Test temporary dir decoding with arguments. Source code in tests\\test_torrentfile.py def test_exception_decoding_error (): \"\"\"Test temporary dir decoding with arguments.\"\"\" try : val = b \"i:alphabet\" decoder = utils . Bendecoder () val = decoder . decode ( val ) assert False # nosec except exceptions . BendecodingError : assert True # nosec test_exception_encoding_error () Test temporary dir encoding with arguments. Source code in tests\\test_torrentfile.py def test_exception_encoding_error (): \"\"\"Test temporary dir encoding with arguments.\"\"\" try : val = set ([ 1 , 2 , 3 , 4 , 5 ]) encoder = utils . Benencoder () val = encoder . encode ( val ) assert False # nosec except exceptions . BenencodingError : assert True # nosec test_exception_path_error () Test MissingPathError exception. Source code in tests\\test_torrentfile.py def test_exception_path_error (): \"\"\"Test MissingPathError exception.\"\"\" try : raise exceptions . MissingPathError ( \"this is a message\" ) except exceptions . MissingPathError : assert True # nosec test_torrentfile_dir ( tdir ) Test temporary directory. Source code in tests\\test_torrentfile.py def test_torrentfile_dir ( tdir ): \"\"\"Test temporary directory.\"\"\" _ , args = tdir torrent = TorrentFile ( ** args ) data = torrent . assemble () assert data is not None # nosec test_torrentfile_dir_comment ( tdir ) Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_comment ( tdir ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir args [ \"private\" ] = True args [ \"comment\" ] = \"This is a comment\" torrent = TorrentFile ( ** args ) data = torrent . assemble () assert \"private\" in data [ \"info\" ] and \"comment\" in data [ \"info\" ] # nosec test_torrentfile_dir_private ( tdir ) Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_private ( tdir ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir args [ \"private\" ] = True torrent = TorrentFile ( ** args ) data = torrent . assemble () assert \"private\" in data [ \"info\" ] # nosec test_torrentfile_file ( tfile ) Test temporary file. Source code in tests\\test_torrentfile.py def test_torrentfile_file ( tfile ): \"\"\"Test temporary file.\"\"\" _ , args = tfile torrent = TorrentFile ( ** args ) data = torrent . assemble () assert data is not None # nosec test_torrentfile_file_comment ( tfile ) Test temporary file with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_file_comment ( tfile ): \"\"\"Test temporary file with arguments.\"\"\" _ , args = tfile args [ \"private\" ] = True args [ \"comment\" ] = \"This is a comment\" torrent = TorrentFile ( ** args ) data = torrent . assemble () assert \"private\" in data [ \"info\" ] and \"comment\" in data [ \"info\" ] # nosec test_torrentfile_file_private ( tfile ) Test temporary file with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_file_private ( tfile ): \"\"\"Test temporary file with arguments.\"\"\" _ , args = tfile args [ \"private\" ] = True torrent = TorrentFile ( ** args ) data = torrent . assemble () assert \"private\" in data [ \"info\" ] # nosec tfile () Return temporary file. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Return temporary file.\"\"\" fd = tempfile () args = { \"path\" : fd , \"announce\" : \"https://tracker.com/announce\" } yield ( fd , args ) rmpath ( fd ) test_utils Test functions for utils module. bencode ( metadata ) Test encoding in bencode format. Source code in tests\\test_utils.py @pytest . fixture def bencode ( metadata ): \"\"\"Test encoding in bencode format.\"\"\" encoder = Benencoder ( metadata ) data = encoder . encode () return data metadata () Return preconfigured metadata. Source code in tests\\test_utils.py @pytest . fixture def metadata (): \"\"\"Return preconfigured metadata.\"\"\" meta = { \"announce\" : \"https://tracker.com:2017/announce\" , \"created by\" : \"torrentfile\" , \"piece length\" : MAX_BLOCK , \"info\" : { \"name\" : \"torrentname.bin\" , \"files\" : [ { \"length\" : 2 ** 28 , \"path\" : [ \"path\" , \"to\" , \"content\" ]}, { \"length\" : 2 ** 28 , \"path\" : [ \"path\" , \"more\" , \"content\" ]}, ], \"pieces\" : b \"some bytes of data\" , \"source\" : \"tracker\" , \"private\" : 1 , }, } return meta tdir () Return temporary directory. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" ) def tdir (): \"\"\"Return temporary directory.\"\"\" drct = tempdir () yield drct rmpath ( drct ) test_decode ( bencode ) Test Bendecoder. Source code in tests\\test_utils.py def test_decode ( bencode ): \"\"\"Test Bendecoder.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert data is not None # nosec test_decode_type ( bencode ) Test Bendecoder output type. Source code in tests\\test_utils.py def test_decode_type ( bencode ): \"\"\"Test Bendecoder output type.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert isinstance ( data , dict ) # nosec test_decode_type_announce ( bencode ) Test Benencoder output contents. Source code in tests\\test_utils.py def test_decode_type_announce ( bencode ): \"\"\"Test Benencoder output contents.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert \"announce\" in data # nosec test_decode_type_created_by ( bencode ) Test Bendecoder output type. Source code in tests\\test_utils.py def test_decode_type_created_by ( bencode ): \"\"\"Test Bendecoder output type.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert \"created by\" in data # nosec test_decode_type_info ( bencode ) Test Benencoder output contents type. Source code in tests\\test_utils.py def test_decode_type_info ( bencode ): \"\"\"Test Benencoder output contents type.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert \"info\" in data # nosec test_decode_type_piecelength ( bencode ) Test Bendecoder output contents. Source code in tests\\test_utils.py def test_decode_type_piecelength ( bencode ): \"\"\"Test Bendecoder output contents.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert \"piece length\" in data # nosec test_encode ( metadata ) Test Benencoder. Source code in tests\\test_utils.py def test_encode ( metadata ): \"\"\"Test Benencoder.\"\"\" encoder = Benencoder ( metadata ) data = encoder . encode () assert data is not None # nosec test_encode_type ( metadata ) Test Benencoder output type. Source code in tests\\test_utils.py def test_encode_type ( metadata ): \"\"\"Test Benencoder output type.\"\"\" encoder = Benencoder ( metadata ) data = encoder . encode () assert isinstance ( data , bytes ) # nosec test_get_file_list_dir ( tdir ) Test get_file_list function for tempdir. Source code in tests\\test_utils.py def test_get_file_list_dir ( tdir ): \"\"\"Test get_file_list function for tempdir.\"\"\" results = get_file_list ( tdir ) assert len ( results ) > 1 # nosec test_get_file_list_dir_sort ( tdir ) Test get_file_list function for tempdir sorted. Source code in tests\\test_utils.py def test_get_file_list_dir_sort ( tdir ): \"\"\"Test get_file_list function for tempdir sorted.\"\"\" results = get_file_list ( tdir , sort = True ) assert len ( results ) > 1 # nosec test_get_file_list_file ( tfile ) Test get_file_list function for tempfile. Source code in tests\\test_utils.py def test_get_file_list_file ( tfile ): \"\"\"Test get_file_list function for tempfile.\"\"\" results = get_file_list ( tfile ) assert len ( results ) == 1 # nosec test_get_piece_len ( tfile ) Test get_piece_length function does not exceed max. Source code in tests\\test_utils.py def test_get_piece_len ( tfile ): \"\"\"Test get_piece_length function does not exceed max.\"\"\" size = os . path . getsize ( tfile ) result = get_piece_length ( size ) assert result <= MAX_BLOCK # nosec test_get_piece_len_large () Test get_piece_length function does not exceed maximum. Source code in tests\\test_utils.py def test_get_piece_len_large (): \"\"\"Test get_piece_length function does not exceed maximum.\"\"\" size = 2 ** 31 result = get_piece_length ( size ) assert result <= MAX_BLOCK # nosec test_get_piece_len_power_2 ( tfile ) Test get_piece_length function is a power of 2. Source code in tests\\test_utils.py def test_get_piece_len_power_2 ( tfile ): \"\"\"Test get_piece_length function is a power of 2.\"\"\" size = os . path . getsize ( tfile ) result = get_piece_length ( size ) assert result % MIN_BLOCK == 0 # nosec test_get_piece_length_min ( tfile ) Test get_piece_length function does not fall under minimum. Source code in tests\\test_utils.py def test_get_piece_length_min ( tfile ): \"\"\"Test get_piece_length function does not fall under minimum.\"\"\" size = os . path . getsize ( tfile ) result = get_piece_length ( size ) assert result >= MIN_BLOCK # nosec test_path_piece_length_max ( tdir ) Test path_piece_length for dir return piece_length < Maximum. Source code in tests\\test_utils.py def test_path_piece_length_max ( tdir ): \"\"\"Test path_piece_length for dir return piece_length < Maximum.\"\"\" result = path_piece_length ( tdir ) assert result <= MAX_BLOCK # nosec test_path_piece_length_min ( tdir ) Test path_piece_length for dir return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_min ( tdir ): \"\"\"Test path_piece_length for dir return piece_length is power of 2.\"\"\" result = path_piece_length ( tdir ) assert result >= MIN_BLOCK # nosec test_path_piece_length_pow2 ( tdir ) Test path_piece_length for file return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_pow2 ( tdir ): \"\"\"Test path_piece_length for file return piece_length is power of 2.\"\"\" result = path_piece_length ( tdir ) assert result % MIN_BLOCK == 0 # nosec test_path_size_file ( tfile ) Test path_size function for tempfile. Source code in tests\\test_utils.py def test_path_size_file ( tfile ): \"\"\"Test path_size function for tempfile.\"\"\" size = os . path . getsize ( tfile ) val = path_size ( tfile ) assert size == val # nosec test_path_size_file_gt0 ( tfile ) Test path_size function for tempfile is greater than zero. Source code in tests\\test_utils.py def test_path_size_file_gt0 ( tfile ): \"\"\"Test path_size function for tempfile is greater than zero.\"\"\" val = path_size ( tfile ) assert val > 0 # nosec test_path_stat_base2_plen ( tdir ) Test path_stat function return piece length is power of 2. Source code in tests\\test_utils.py def test_path_stat_base2_plen ( tdir ): \"\"\"Test path_stat function return piece length is power of 2.\"\"\" _ , _ , piece_length = path_stat ( tdir ) assert piece_length % MIN_BLOCK == 0 # nosec test_path_stat_eq_filelist ( tdir ) Test path_stat function return filelist. Source code in tests\\test_utils.py def test_path_stat_eq_filelist ( tdir ): \"\"\"Test path_stat function return filelist.\"\"\" filelist , _ , _ = path_stat ( tdir ) assert len ( filelist ) > 1 # nosec test_path_stat_eq_size ( tdir ) Test path_stat function return identically correct size. Source code in tests\\test_utils.py def test_path_stat_eq_size ( tdir ): \"\"\"Test path_stat function return identically correct size.\"\"\" filelist , size , _ = path_stat ( tdir ) assert size == sum ([ os . path . getsize ( x ) for x in filelist ]) # nosec test_path_stat_gt0_filelist ( tdir ) Test path_stat function for tempdir sorted > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_filelist ( tdir ): \"\"\"Test path_stat function for tempdir sorted > 0.\"\"\" filelist , _ , _ = path_stat ( tdir ) assert len ( filelist ) > 0 # nosec test_path_stat_gt0_plen ( tdir ) Test path_stat function return piece length > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_plen ( tdir ): \"\"\"Test path_stat function return piece length > 0.\"\"\" _ , _ , piece_length = path_stat ( tdir ) assert piece_length >= MIN_BLOCK # nosec test_path_stat_gt0_size ( tdir ) Test path_stat function return size > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_size ( tdir ): \"\"\"Test path_stat function return size > 0.\"\"\" _ , size , _ = path_stat ( tdir ) assert size > 0 # nosec test_path_stat_gtsize_plen ( tdir ) Test path_stat function return size > piece length. Source code in tests\\test_utils.py def test_path_stat_gtsize_plen ( tdir ): \"\"\"Test path_stat function return size > piece length.\"\"\" _ , size , piece_length = path_stat ( tdir ) assert size > piece_length # nosec tfile () Return temporary file. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Return temporary file.\"\"\" testfile = tempfile () yield testfile rmpath ( testfile )","title":"API"},{"location":"api/#api-reference","text":"Torrentfile can create Bittorrent metafiles for any content. Both Bittorrent v1 and v2 are fully supported. Also included is a torrent torrent file checker, which can verify a .torrent file is formated correctly as well as validate files and folders against metadata. !!! modules metafile: Creation/Validation of v1 .torrent files. metafile2: Creation/Validation of v2 .torrent files. torrentfile: torrentfiles Command Line Interface implementation. exceptions: Custom Exceptions used in package. utils: Utilities used throughout package. Main script entrypoint for creating .torrent files. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. !!! functions main_script: process command line arguments and run program.","title":"API Reference"},{"location":"api/#torrentfile.torrentfile.main","text":"Initiate main function for CLI script. Source code in torrentfile\\torrentfile.py def main (): \"\"\"Initiate main function for CLI script.\"\"\" return main_script ()","title":"main()"},{"location":"api/#torrentfile.torrentfile.main_script","text":"Initialize Command Line Interface for torrentfile. !!! usage \"torrentfile --path /path/to/content [-o /path/to/output.torrent]\" --piece-length n [-t https://tracker.url/announce] [--v2] [--source x] [--announce-list tracker.url2 tracker.url3] [-h] Source code in torrentfile\\torrentfile.py def main_script ( args = None ): \"\"\"Initialize Command Line Interface for torrentfile. usage: torrentfile --path /path/to/content [-o /path/to/output.torrent] [--piece-length n] [--private] [-t https://tracker.url/announce] [--v2] [--source x] [--announce-list tracker.url2 tracker.url3] [-h] \"\"\" if not args : args = sys . argv [ 1 :] usage = \"\"\"torrentfile -v -h --path </path/to/content> [-o <output/path.torrent>] [--piece-length <n>] [--private] [-a https://tracker.url/announce] [--meta-version <n>] [--source <x>] [--announce-list <url2> <...>]\"\"\" d = \"Create .torrent files for Bittorrent v1 or v2.\" parser = ArgumentParser ( \"torrentfile\" , description = d , prefix_chars = \"-\" , usage = usage ) parser . add_argument ( \"--version\" , action = \"version\" , version = f \"torrentfile v { torrentfile . __version__ } \" , help = \"show program version and exit \\n \" , ) parser . add_argument ( \"-p\" , \"--path\" , action = \"store\" , dest = \"path\" , metavar = \"<path>\" , help = \"(required) path to torrent content\" , ) parser . add_argument ( \"-a\" , \"--announce\" , action = \"store\" , dest = \"announce\" , metavar = \"<url>\" , help = \"Primary tracker url.\" , ) parser . add_argument ( \"--piece-length\" , action = \"store\" , dest = \"piece_length\" , metavar = \"<n>\" , help = \"Transmit size for pieces of torrent content.\" , ) parser . add_argument ( \"--private\" , action = \"store_true\" , dest = \"private\" , help = \"For torrents distributed on private trackers.\" , ) parser . add_argument ( \"-o\" , \"--out\" , action = \"store\" , help = \"Specify path for .torrent file.\" , dest = \"outfile\" , metavar = \"<path>\" , ) parser . add_argument ( \"--meta-version\" , choices = [ \"1\" , \"2\" , \"3\" ], action = \"store\" , help = ( \"Specify the version of torrent metafile to create.\" \"1 = v1, 2 = v2, 3 = 1 & 2 Hybrid\" ), default = \"1\" , dest = \"meta_version\" , metavar = \"<n>\" , ) parser . add_argument ( \"--comment\" , action = \"store\" , dest = \"comment\" , metavar = \"<comment>\" , help = \"Include a comment in file metadata.\" , ) parser . add_argument ( \"--source\" , action = \"store\" , dest = \"source\" , metavar = \"<source>\" , help = \"ignore unless instructed otherwise\" , ) parser . add_argument ( \"--announce-list\" , action = \"extend\" , dest = \"announce_list\" , nargs = \"+\" , metavar = \"[<url>, ...]\" , help = \"Additional tracker url's\" , ) if not args : args = [ \"-h\" ] flags = parser . parse_args ( args ) if not flags . path : raise MissingPathError ( flags ) kwargs = { \"path\" : flags . path , \"announce\" : flags . announce , \"announce_list\" : flags . announce_list , \"piece_length\" : flags . piece_length , \"source\" : flags . source , \"private\" : flags . private , \"outfile\" : flags . outfile , \"comment\" : flags . comment , } print ( flags ) if flags . meta_version == \"2\" : torrent = TorrentFileV2 ( ** kwargs ) elif flags . meta_version == \"1\" : torrent = TorrentFile ( ** kwargs ) elif flags . meta_version == \"3\" : torrent = TorrentFileHybrid ( ** kwargs ) else : raise MissingPathError ( flags ) torrent . assemble () outfile , meta = torrent . write () parser . kwargs = kwargs parser . meta = meta parser . outfile = outfile return parser Creating and verfying Bittorrent v1 metafiles (.torrent).","title":"main_script()"},{"location":"api/#torrentfile.metafile--notes","text":"From Bittorrent.org Documentation pages. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: announce The URL of the tracker. info This maps to a dictionary, with keys described below. All strings in a .torrent file that contains text must be UTF-8 encoded.","title":"Notes"},{"location":"api/#torrentfile.metafile--info-dictionary","text":"The name key maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length is almost always a power of two, most commonly 2 18 = 256 K (BitTorrent prior to version 3.2 uses 2 20 = 1 M as default). pieces maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. There is also a key length or a key files , but not both or neither. If length is present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. In the single file case, length maps to the length of the file in bytes. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: length - The length of the file, in bytes. path - A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name (a zero length list is an error case). In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory.","title":"info dictionary"},{"location":"api/#torrentfile.metafile.Checker","text":"Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters: Name Type Description Default metafile ( str ): Path to \".torrent\" file. required location(`str`) Path where the content is located in filesystem. required Examples: metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\" location = \"/path/to/location\" os.path.exists(\"/path/to/location/content_file_or_dir\") Out: True checker = Checker(metafile, location)","title":"Checker"},{"location":"api/#torrentfile.metafile.Checker.__init__","text":"Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters: Name Type Description Default metafile ( str ): Path to \".torrent\" file. required location(`str`) Path where the content is located in filesystem. required Source code in torrentfile\\metafile.py def __init__ ( self , metafile , location ): \"\"\" Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Args: metafile:(`str`): Path to \".torrent\" file. location(`str`): Path where the content is located in filesystem. \"\"\" self . metafile = metafile self . location = location self . meta = {} self . info = {} self . total = 0 self . piece_length = None self . files = None self . name = None self . paths = [] self . fileinfo = {} self . status = 0","title":"__init__()"},{"location":"api/#torrentfile.metafile.Checker.check","text":"Check if all components work as expected. Source code in torrentfile\\metafile.py def check ( self ): \"\"\"Check if all components work as expected.\"\"\" self . decode_metafile () self . get_paths () status = self . check_path () return status","title":"check()"},{"location":"api/#torrentfile.metafile.Checker.check_path","text":"Check if path exists and is the correct size and hash. Returns: Type Description `str` Indicating process has completed. Source code in torrentfile\\metafile.py def check_path ( self ): \"\"\" Check if path exists and is the correct size and hash. Returns: `str`: Indicating process has completed. \"\"\" if os . path . isfile ( self . location ): if os . path . basename ( self . location ) == self . name : paths = [ self . location ] else : paths = [ os . path . join ( self . location , i ) for i in self . paths ] return self . _check_path ( paths )","title":"check_path()"},{"location":"api/#torrentfile.metafile.Checker.decode_metafile","text":"Decode bencoded data inside .torrent file. Source code in torrentfile\\metafile.py def decode_metafile ( self ): \"\"\"Decode bencoded data inside .torrent file.\"\"\" fd = open ( self . metafile , \"rb\" ) . read () decoder = Bendecoder () terms = decoder . decode ( fd ) for key , val in terms . items (): self . meta [ key ] = val if key == \"info\" : for key1 , val1 in val . items (): self . info [ key1 ] = val1 self . piece_length = self . info [ \"piece length\" ] self . pieces = self . info [ \"pieces\" ] self . name = self . info [ \"name\" ] if \"length\" not in self . info : self . files = self . info [ \"files\" ]","title":"decode_metafile()"},{"location":"api/#torrentfile.metafile.Checker.get_paths","text":"Get list of paths from files list inside .torrent file. Source code in torrentfile\\metafile.py def get_paths ( self ): \"\"\"Get list of paths from files list inside .torrent file.\"\"\" if not self . files : self . paths . append ( self . name ) self . fileinfo [ self . name ] = self . info [ \"length\" ] else : for item in self . files : size = item [ \"length\" ] self . total += size path = os . path . join ( * item [ \"path\" ]) self . paths . append ( path ) self . fileinfo [ path ] = size return self . paths","title":"get_paths()"},{"location":"api/#torrentfile.metafile.Feeder","text":"Construct the Feeder class. Seemlesly generate hashes of piece length data from filelist contents. Parameters: Name Type Description Default paths(`list`) List of files. required piece_length(`int`) Size of chuncks to split the data into. required total(`int`) Sum of all files in file list. required","title":"Feeder"},{"location":"api/#torrentfile.metafile.Feeder.__init__","text":"Construct the Feeder class. Generate hashes of piece length data from filelist contents. Parameters: Name Type Description Default paths(`list`) List of files. required piece_length(`int`) Size of chuncks to split the data into. required total(`int`) Sum of all files in file list. required Source code in torrentfile\\metafile.py def __init__ ( self , paths , piece_length , total ): \"\"\" Construct the Feeder class. Generate hashes of piece length data from filelist contents. Args: paths(`list`): List of files. piece_length(`int`): Size of chuncks to split the data into. total(`int`): Sum of all files in file list. \"\"\" self . piece_length = piece_length self . paths = paths self . total = total self . pieces = [] self . index = 0 self . current = open ( self . paths [ self . index ], \"rb\" ) self . iterator = self . leaves ()","title":"__init__()"},{"location":"api/#torrentfile.metafile.Feeder.__iter__","text":"Iterate through feed pieces. Returns: Type Description `iter(self)` Iterator for leaves/hash pieces. Source code in torrentfile\\metafile.py def __iter__ ( self ): \"\"\" Iterate through feed pieces. Returns: `iter(self)`: Iterator for leaves/hash pieces. \"\"\" self . iterator = self . leaves () return self . iterator","title":"__iter__()"},{"location":"api/#torrentfile.metafile.Feeder.__next__","text":"Return the next element from iterator. Returns: Type Description `bytes` Piece_length length pieces of data. Source code in torrentfile\\metafile.py def __next__ ( self ): \"\"\" Return the next element from iterator. Returns: `bytes`: Piece_length length pieces of data. \"\"\" return self . iterator . __next__ ()","title":"__next__()"},{"location":"api/#torrentfile.metafile.Feeder.handle_partial","text":"Seemlessly move to next file for input data. Parameters: Name Type Description Default arr(`bytearray`) Incomplete piece containing partial data required partial(`int`) Size of incomplete piece_length required Returns: Type Description `bytes` SHA1 digest of the complete piece. Source code in torrentfile\\metafile.py def handle_partial ( self , arr , partial ): \"\"\" Seemlessly move to next file for input data. Args: arr(`bytearray`): Incomplete piece containing partial data partial(`int`): Size of incomplete piece_length Returns: `bytes`: SHA1 digest of the complete piece. \"\"\" while partial < self . piece_length : temp = bytearray ( self . piece_length - partial ) size = self . current . readinto ( temp ) acc = partial + size arr [ partial : acc ] = temp [: size ] partial += size if partial < self . piece_length : if not self . next_file (): return sha1 ( arr [: partial ]) . digest () # nosec return sha1 ( arr ) . digest () # nosec","title":"handle_partial()"},{"location":"api/#torrentfile.metafile.Feeder.leaves","text":"Generate piece-length pieces of data from input file list. Source code in torrentfile\\metafile.py def leaves ( self ): \"\"\"Generate piece-length pieces of data from input file list.\"\"\" while True : piece = bytearray ( self . piece_length ) size = self . current . readinto ( piece ) if size == 0 : if not self . next_file (): self . current . close () break elif size < self . piece_length : yield self . handle_partial ( piece , size ) else : yield sha1 ( piece ) . digest () # nosec","title":"leaves()"},{"location":"api/#torrentfile.metafile.Feeder.next_file","text":"Seemlessly transition to next file in file list. Source code in torrentfile\\metafile.py def next_file ( self ): \"\"\"Seemlessly transition to next file in file list.\"\"\" self . index += 1 if self . index < len ( self . paths ): self . current . close () self . current = open ( self . paths [ self . index ], \"rb\" ) return True return False","title":"next_file()"},{"location":"api/#torrentfile.metafile.Feeder.total_pieces","text":"Total size / piece length. Source code in torrentfile\\metafile.py def total_pieces ( self ): \"\"\"Total size / piece length.\"\"\" return math . ceil ( self . total // self . piece_length )","title":"total_pieces()"},{"location":"api/#torrentfile.metafile.TorrentFile","text":"Class for creating Bittorrent meta files. Construct Torrentfile class instance object. Parameters: Name Type Description Default path(`str`) Path to torrent file or directory. required piece_length(`int`) Size of each piece of torrent data. required announce(`str`) Tracker URL. required announce_list(`str` or `list` Additional Tracker URLs. required private(`int`) 1 if private torrent else 0. required source(`str`) Source tracker. required comment(`str`) Comment string. required outfile(`str`) Path to write metfile to. required Returns: Type Description `obj` Instance of Metafile Class.","title":"TorrentFile"},{"location":"api/#torrentfile.metafile.TorrentFile.__init__","text":"Class for creating Bittorrent meta files from given parameters. Construct Torrentfile class instance object. Parameters: Name Type Description Default path('str') source path to torrent content. required announce('str') tracker URL. required announce_list('list') additional tracker URLS. required private('bool') used for private trackers. required comment('str') a comment. required outfile('str') target destination path. required source('str') used for private trackers. required Returns: Type Description `Torrentfile` Instance of Metafile Class. Source code in torrentfile\\metafile.py def __init__ ( self , path = None , announce = None , announce_list = None , private = False , source = None , piece_length = None , comment = None , outfile = None ): \"\"\" Class for creating Bittorrent meta files from given parameters. Construct *Torrentfile* class instance object. Args: path('str'): source path to torrent content. announce('str'): tracker URL. announce_list('list'): additional tracker URLS. private('bool'): used for private trackers. comment('str'): a comment. outfile('str'): target destination path. source('str'): used for private trackers. Returns: `Torrentfile`: Instance of Metafile Class. \"\"\" # fs path attributes. self . path = path self . name = os . path . basename ( path ) self . outfile = outfile # if `piece_length` is a `str` turn it into an `int`. if piece_length : self . piece_length = int ( piece_length ) else : self . piece_length = None self . announce = announce if announce : self . announce = announce else : self . announce = \"\" # If announce `list` is a `str` split it up. if isinstance ( announce_list , str ): self . announce_list = re . split ( r \"[\\s,]\" , announce_list ) else : self . announce_list = announce_list # for private trackers. self . private = private self . source = source # other less common flags. self . comment = comment self . meta = self . assemble ()","title":"__init__()"},{"location":"api/#torrentfile.metafile.TorrentFile.assemble","text":"Assemble components of torrent metafile. Returns: Type Description `dict` metadata dictionary for torrent file Source code in torrentfile\\metafile.py def assemble ( self ): \"\"\" Assemble components of torrent metafile. Returns: `dict`: metadata dictionary for torrent file \"\"\" meta = { \"announce\" : self . announce } meta [ \"created by\" ] = \"torrentfile\" meta [ \"creation date\" ] = int ( dt . timestamp ( dt . now ())) meta [ \"info\" ] = self . _assemble_infodict () return meta","title":"assemble()"},{"location":"api/#torrentfile.metafile.TorrentFile.write","text":"Write assembled data to .torrent file. Parameters: Name Type Description Default outfile (Default value = None) None Returns: Type Description `tuple` Path to output file, Pre-encoded metadata. Source code in torrentfile\\metafile.py def write ( self , outfile = None ): \"\"\" Write assembled data to .torrent file. Args: outfile: (Default value = None) Returns: `tuple`: Path to output file, Pre-encoded metadata. \"\"\" encoder = Benencoder () data = encoder . encode ( self . meta ) if not outfile : if not self . outfile : self . outfile = self . meta [ \"info\" ][ \"name\" ] + \".torrent\" else : self . outfile = outfile with open ( self . outfile , \"wb\" ) as fd : fd . write ( data ) return ( self . outfile , self . meta ) Metafile procedures for Bittorrent v2. This module metafile2 contains classes and functions related to constructing .torrent files using Bittorrent v2 Protocol !!! classes TorrentFileV2 : construct .torrent files using provided data. FileHash : Calculates leaf hashes and root hashes for torrent contents. !!! constants BLOCK_SIZE( int ): size of leaf hashes for merkle tree.","title":"write()"},{"location":"api/#torrentfile.metafile2--notes","text":"Implementation details for Bittorrent Protocol v2. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: \"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' in this context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On most platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require valid UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in the same order as in the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key.","title":"Notes"},{"location":"api/#torrentfile.metafile2--file-tree-layout-example","text":"{info: {file tree: {dir1: {dir2: {fileA.txt: { \"\": {length: <length of file in bytes (integer)>, pieces root: <optional, merkle tree root (string)>} }, fileB.txt: { \"\": {length: `int`, pieces root: `string`} }} } } } } Note that identical files always result in the same root hash. All strings in a .torrent file defined by this BEP that contain human-readable text are UTF-8 encoded. Single-file torrent: \"file tree\": {name.ext: {\"\": {length: ...}}} Multiple files rooted in a single directory: python: \"file tree\": {dir: { nameA.ext: {\"\": {length: ...}}, nameB.ext: {\"\": {length: ...}}}}","title":"File tree layout Example:"},{"location":"api/#torrentfile.metafile2.FileHash","text":"Calculate and store hash information for specific file. Parameters: Name Type Description Default path(`str`) Absolute path to file. required piece_length(`int`) Size of each metfile piece. required Returns: Type Description `obj` Instance of FileHash.","title":"FileHash"},{"location":"api/#torrentfile.metafile2.FileHash.__init__","text":"Calculate and store hash information for specific file. Parameters: Name Type Description Default path(`str`) Absolute path to file. required piece_length(`int`) Size of each metfile piece. required Returns: Type Description `obj` Instance of FileHash. Source code in torrentfile\\metafile2.py def __init__ ( self , path , piece_length ): \"\"\" Calculate and store hash information for specific file. Args: path(`str`): Absolute path to file. piece_length(`int`): Size of each metfile piece. Returns: `obj`: Instance of FileHash. \"\"\" self . path = path self . root_hash = None self . piece_layers = None self . layer_hashes = [] self . piece_length = piece_length self . piece_blocks = piece_length // BLOCK_SIZE with open ( self . path , \"rb\" ) as fd : self . _process_file ( fd )","title":"__init__()"},{"location":"api/#torrentfile.metafile2.TorrentFileV2","text":"Class for creating Bittorrent meta v2 files. Parameters: Name Type Description Default path(`str`) Path to torrent file or directory. required piece_length(`int`) Size of each piece of torrent data. required announce(`str`) Tracker URL. required announce_list('list`) List of additional trackers. required private(`int`) 1 if private torrent else 0. required source(`str`) Source tracker. required comment(`str`) Comment string. required outfile(`str`) Path to write metfile to. required Returns: Type Description `obj` Instance of Metafile Class.","title":"TorrentFileV2"},{"location":"api/#torrentfile.metafile2.TorrentFileV2.__init__","text":"Construct TorrentFileV2 Class instance from given parameters. Parameters: Name Type Description Default path(`str`) Path to torrent file or directory. required piece_length(`int`) Size of each piece of torrent data. required announce(`str`) Tracker URL. required announce_list('list`) List of additional trackers. required private(`int`) 1 if private torrent else 0. required source(`str`) Source tracker. required comment(`str`) Comment string. required outfile(`str`) Path to write metfile to. required Returns: Type Description `obj` Instance of Metafile Class. Source code in torrentfile\\metafile2.py def __init__ ( self , path = None , source = None , outfile = None , announce = None , announce_list = None , comment = None , private = None , piece_length = None ,): \"\"\" Construct `TorrentFileV2` Class instance from given parameters. Args: path(`str`): Path to torrent file or directory. piece_length(`int`): Size of each piece of torrent data. announce(`str`): Tracker URL. announce_list('list`): List of additional trackers. private(`int`): 1 if private torrent else 0. source(`str`): Source tracker. comment(`str`): Comment string. outfile(`str`): Path to write metfile to. Returns: `obj`: Instance of Metafile Class. \"\"\" self . name = os . path . basename ( path ) self . path = path self . comment = comment self . piece_length = piece_length self . private = private self . source = source self . announce = announce self . announce_list = announce_list self . outfile = outfile self . hashes = [] self . piece_layers = {} self . meta = self . assemble ()","title":"__init__()"},{"location":"api/#torrentfile.metafile2.TorrentFileV2.assemble","text":"Assemble then return the meta dictionary for encoding. Returns: Type Description meta(`dict`) Metainformation about the torrent. Source code in torrentfile\\metafile2.py def assemble ( self ): \"\"\" Assemble then return the meta dictionary for encoding. Returns: meta(`dict`): Metainformation about the torrent. \"\"\" # if no tracker url was provided, place dummy string in its place # which can be later replaced by some Bittorrent clients if not self . piece_length : self . piece_length = path_piece_length ( self . path ) elif isinstance ( self . piece_length , str ): self . piece_length = int ( self . piece_length ) if self . announce : meta = { \"announce\" : self . announce } else : meta = { \"announce\" : \"\" } meta [ \"created by\" ] = \"torrentfile\" meta [ \"creation date\" ] = int ( datetime . timestamp ( datetime . now ())) # assemble info dictionary and assign it to info key in meta meta [ \"info\" ] = self . _assemble_infodict () for hasher in self . hashes : if hasher . piece_layers : self . piece_layers [ hasher . root_hash ] = hasher . piece_layers meta [ \"piece layers\" ] = self . piece_layers return meta","title":"assemble()"},{"location":"api/#torrentfile.metafile2.TorrentFileV2.write","text":"Write assembled data to .torrent file. Parameters: Name Type Description Default outfile(`str`) Path to save location. required Returns: Type Description `bytes` Data writtend to .torrent file. Source code in torrentfile\\metafile2.py def write ( self , outfile = None ): \"\"\" Write assembled data to .torrent file. Args: outfile(`str`): Path to save location. Returns: `bytes`: Data writtend to .torrent file. \"\"\" encoder = Benencoder () self . data = encoder . encode ( self . meta ) if outfile : self . outfile = outfile elif not self . outfile : self . outfile = self . meta [ \"info\" ][ \"name\" ] + \".torrent\" with open ( self . outfile , \"wb\" ) as fd : fd . write ( self . data ) return self . outfile , self . meta","title":"write()"},{"location":"api/#torrentfile.metafile2.merkle_root","text":"Generate root hash of a merkle Tree with input as leaves. Source code in torrentfile\\metafile2.py def merkle_root ( pieces ): \"\"\"Generate root hash of a merkle Tree with input as leaves.\"\"\" while len ( pieces ) > 1 : pieces = [ sha256 ( x + y ) . digest () for x , y in zip ( * [ iter ( pieces )] * 2 )] return pieces [ 0 ] Classes and procedures for making Bittorrent metafiles. Creating .torrent files that support both Bittorrent v1 & v2 metadata structure and hashes simultaneously. This module was partly influenced by \"bep_0052_torrent_creator\". !!! classes TorrentFileHybrid Hasher","title":"merkle_root()"},{"location":"api/#torrentfile.hybrid.Hasher","text":"Calculate hashes for Hybrid torrentfile. Parameters: Name Type Description Default path(`str` or pathlike path to target file. required piece_length(`int`) piece length for data chunks. required","title":"Hasher"},{"location":"api/#torrentfile.hybrid.Hasher.__init__","text":"Construct Hasher class instances for each file in torrent. Calculates sha1 and sha256 hashes for each version # nosec of the Bittorrent protocols meta files. Parameters: Name Type Description Default path `str` Path to target file. required piece_length `int` Meta file piece length. required Source code in torrentfile\\hybrid.py def __init__ ( self , path , piece_length ): \"\"\" Construct Hasher class instances for each file in torrent. Calculates sha1 and sha256 hashes for each version # nosec of the Bittorrent protocols meta files. Args: path (`str`): Path to target file. piece_length (`int`): Meta file piece length. \"\"\" self . path = path self . size = 0 self . hashv1 = [] self . hashv2 = [] self . padding_hash = None self . padding_file = None num_blocks = piece_length // BLOCK_SIZE with open ( path , \"rb\" ) as data : block = bytearray ( BLOCK_SIZE ) while True : residue = piece_length v2blocks = [] v1blocks = bytearray () for _ in range ( num_blocks ): size = data . readinto ( block ) if size == 0 : break self . size += size residue -= size v2blocks . append ( sha256 ( block [: size ]) . digest ()) v1blocks . extend ( block [: size ]) if len ( v2blocks ) == 0 : break if len ( v2blocks ) != num_blocks : if not self . hashv2 : leaves = 1 << ( len ( v2blocks ) - 1 ) . bit_length () else : leaves = num_blocks needed = leaves - len ( v2blocks ) v2blocks . extend ([ bytes ( 32 ) for _ in range ( needed )]) self . _apply_padding ( residue ) self . hashv2 . append ( merkle_root ( v2blocks )) self . hashv1 . append ( sha1 ( v1blocks ) . digest ()) # nosec if self . size > 0 : layer_hashes = self . hashv2 if len ( self . hashv2 ) > 1 : self . hashv2 = b \"\" . join ( self . hashv2 ) pad_piece = merkle_root ([ bytes ( 32 )] * num_blocks ) power_two = 1 << ( len ( layer_hashes ) - 1 ) . bit_length () remainder = power_two - len ( layer_hashes ) layer_hashes . extend ( pad_piece for _ in range ( remainder )) self . _apply_padding (( BLOCK_SIZE * num_blocks ) * remainder ) self . root = merkle_root ( layer_hashes )","title":"__init__()"},{"location":"api/#torrentfile.hybrid.TorrentFileHybrid","text":"Create Bittorrent v1 v2 hybrid metafiles.","title":"TorrentFileHybrid"},{"location":"api/#torrentfile.hybrid.TorrentFileHybrid.__init__","text":"Construct the Hybrid torrent meta file with provided parameters. Parameters: Name Type Description Default path `str` path to torrentfile target. None announce `str` Tracker URL. None announce_list `list` Additional tracker URLs. None comment `str` Some comment. None source `str` Used for private trackers. None outfile `str` target path to write output. None private `bool` Used for private trackers. None piece_length `int` torrentfile data piece length. None Source code in torrentfile\\hybrid.py def __init__ ( self , path = None , announce = None , announce_list = None , comment = None , source = None , outfile = None , private = None , piece_length = None ): \"\"\" Construct the Hybrid torrent meta file with provided parameters. Args: path (`str`): path to torrentfile target. announce (`str`): Tracker URL. announce_list (`list`): Additional tracker URLs. comment (`str`): Some comment. source (`str`): Used for private trackers. outfile (`str`): target path to write output. private (`bool`): Used for private trackers. piece_length (`int`): torrentfile data piece length. \"\"\" self . path = path self . name = os . path . basename ( path ) self . announce = announce self . announce_list = announce_list self . comment = comment self . source = source self . private = private self . piece_length = piece_length self . outfile = outfile self . piece_layers = [] self . pieces = [] self . files = [] self . residuals = None self . meta = self . assemble ()","title":"__init__()"},{"location":"api/#torrentfile.hybrid.TorrentFileHybrid.assemble","text":"Assemble the parts of the torrentfile into meta dictionary. Source code in torrentfile\\hybrid.py def assemble ( self ): \"\"\"Assemble the parts of the torrentfile into meta dictionary.\"\"\" if not self . announce : meta = { \"announce\" : \"\" } else : meta = { \"announce\" : self . announce } meta [ \"created by\" ] = \"torrentfile\" meta [ \"creation date\" ] = int ( datetime . timestamp ( datetime . now ())) meta [ \"info\" ] = self . _assemble_infodict () meta [ \"pieces\" ] = self . pieces meta [ \"piece_layers\" ] = self . piece_layers return meta","title":"assemble()"},{"location":"api/#torrentfile.hybrid.TorrentFileHybrid.write","text":"Create a Hybrid metainfo dictionary. Parameters: Name Type Description Default outfile(`str` or `path-like` where to write file to. required Source code in torrentfile\\hybrid.py def write ( self , outfile = None ): \"\"\" Create a Hybrid metainfo dictionary. Args: outfile(`str` or `path-like`): where to write file to. \"\"\" if outfile : self . outfile = outfile elif not self . outfile : self . outfile = os . path . basename ( self . path ) + \".torrent\" encoder = Benencoder () data = encoder . encode ( self . meta ) with open ( self . outfile , \"wb\" ) as fd : fd . write ( data ) return ( self . outfile , self . meta )","title":"write()"},{"location":"api/#torrentfile.hybrid.merkle_root","text":"Calculate the merkle root for a seq of sha256 hash digests. Source code in torrentfile\\hybrid.py def merkle_root ( blocks ): \"\"\"Calculate the merkle root for a seq of sha256 hash digests.\"\"\" while len ( blocks ) > 1 : blocks = [ sha256 ( l + r ) . digest () for l , r in zip ( * [ iter ( blocks )] * 2 )] return blocks [ 0 ] Utility functions and classes used throughout package. Classes: Bendecoder: Decoder for bencode data. Benencoder: Encode data to bencode data. Functions: get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory.","title":"merkle_root()"},{"location":"api/#torrentfile.utils.Bendecoder","text":"Bendecoder class contains all decode and convenience methods. Initialize instance with optional pre compiled data. Parameters: Name Type Description Default data(`bytes`) Target data for decoding. required","title":"Bendecoder"},{"location":"api/#torrentfile.utils.Bendecoder.__init__","text":"Bendecoder class contains all decode and convenience methods. Initialize instance with optional pre compiled data. Parameters: Name Type Description Default data(`bytes`) Target data for decoding. required Source code in torrentfile\\utils.py def __init__ ( self , data = None ): \"\"\"Bendecoder class contains all decode and convenience methods. Initialize instance with optional pre compiled data. Args: data(`bytes`): Target data for decoding. \"\"\" self . data = data","title":"__init__()"},{"location":"api/#torrentfile.utils.Bendecoder.decode","text":"Decode bencoded data. Parameters: Name Type Description Default bits(`bytes`) Bencoded data for decoding. required Returns: Type Description `any` The decoded data. Source code in torrentfile\\utils.py def decode ( self , bits = None ): \"\"\"Decode bencoded data. Args: bits(`bytes`): Bencoded data for decoding. Returns: `any`: The decoded data. \"\"\" bits = bits if bits is not None else self . data try : data , _ = self . _decode ( bits ) except AttributeError as excpt : raise BendecodingError ( bits ) from excpt return data","title":"decode()"},{"location":"api/#torrentfile.utils.Benencoder","text":"Encode collection of methods for Bencoding data. Initialize Benencoder insance with optional pre compiled data.","title":"Benencoder"},{"location":"api/#torrentfile.utils.Benencoder.__init__","text":"Initialize Benencoder insance with optional pre compiled data. Parameters: Name Type Description Default data(`any`, optional Target data for encoding. Defaults to None. required Source code in torrentfile\\utils.py def __init__ ( self , data = None ): \"\"\" Initialize Benencoder insance with optional pre compiled data. Args: data(`any`, optional): Target data for encoding. Defaults to None. \"\"\" self . data = data","title":"__init__()"},{"location":"api/#torrentfile.utils.Benencoder.encode","text":"Encode data with bencode encoding. Parameters: Name Type Description Default val(`any`) data to be encoded. required Returns: Type Description `bytes` Decoded data. Source code in torrentfile\\utils.py def encode ( self , val = None ): \"\"\"Encode data with bencode encoding. Args: val(`any`): data to be encoded. Returns: `bytes`: Decoded data. \"\"\" val = val if val is not None else self . data if isinstance ( val , str ): return self . _encode_str ( val ) if hasattr ( val , \"hex\" ): return self . _encode_bytes ( val ) if isinstance ( val , int ): return self . _encode_int ( val ) if isinstance ( val , list ): return self . _encode_list ( val ) if isinstance ( val , dict ): return self . _encode_dict ( val ) if isinstance ( val , bool ): return 1 if val else 0 raise BenencodingError ( val )","title":"encode()"},{"location":"api/#torrentfile.utils.get_file_list","text":"Search directory tree for files. Parameters: Name Type Description Default path(`str`) Path to file or directory base required sort(`bool`) Return list sorted. Defaults to False. required Returns: Type Description `list` All file paths within directory tree. Source code in torrentfile\\utils.py def get_file_list ( path , sort = False ): \"\"\" Search directory tree for files. Args: path(`str`): Path to file or directory base sort(`bool`): Return list sorted. Defaults to False. Returns: `list`: All file paths within directory tree. \"\"\" if os . path . isfile ( path ): return [ path ] # put all files into filelist within directory files = [] filelist = os . listdir ( path ) # optional canonical sort of filelist if sort : filelist . sort ( key = str . lower ) # recursive for all folders for item in filelist : full = os . path . join ( path , item ) files . extend ( get_file_list ( full , sort = sort )) return files","title":"get_file_list()"},{"location":"api/#torrentfile.utils.get_piece_length","text":"Calculate the ideal piece length for bittorrent data. Parameters: Name Type Description Default size(`int`) Total bits of all files incluided in .torrent file. required Returns: Type Description `int` Ideal peace length calculated from the size arguement. Source code in torrentfile\\utils.py def get_piece_length ( size ): \"\"\" Calculate the ideal piece length for bittorrent data. Args: size(`int`): Total bits of all files incluided in .torrent file. Returns: `int`: Ideal peace length calculated from the size arguement. \"\"\" exp = 14 while size / ( 2 ** exp ) > 200 and exp < 23 : exp += 1 return 2 ** exp","title":"get_piece_length()"},{"location":"api/#torrentfile.utils.path_piece_length","text":"Calculate piece length for input path and contents. Parameters: Name Type Description Default path(`str`) The absolute path to directory and contents. required Returns: Type Description piece_length(`int`) The size of pieces of torrent content. Source code in torrentfile\\utils.py def path_piece_length ( path ): \"\"\" Calculate piece length for input path and contents. Args: path(`str`): The absolute path to directory and contents. Returns: piece_length(`int`): The size of pieces of torrent content. \"\"\" psize = path_size ( path ) return get_piece_length ( psize )","title":"path_piece_length()"},{"location":"api/#torrentfile.utils.path_size","text":"Calculate sum of all filesizes within directory. path( str ): The path to start calculating from. Returns: Type Description `int` Total sum in bytes. Source code in torrentfile\\utils.py def path_size ( path ): \"\"\" Calculate sum of all filesizes within directory. Args: path(`str`): The path to start calculating from. Returns: `int`: Total sum in bytes. \"\"\" size = 0 if os . path . isfile ( path ): return os . path . getsize ( path ) # recursive sum for all files in folder if os . path . isdir ( path ): for name in os . listdir ( path ): fullpath = os . path . join ( path , name ) size += path_size ( fullpath ) return size","title":"path_size()"},{"location":"api/#torrentfile.utils.path_stat","text":"Calculate directory statistics. Parameters: Name Type Description Default path(`str`) The path to start calculating from. required Returns: Type Description filelist(`list`) List of all files contained in Directory size( int ): Total sum of bytes from all contents of dir piece_length( int ): The size of pieces of the torrent contents. Source code in torrentfile\\utils.py def path_stat ( path ): \"\"\" Calculate directory statistics. Args: path(`str`): The path to start calculating from. Returns: filelist(`list`): List of all files contained in Directory size(`int`): Total sum of bytes from all contents of dir piece_length(`int`): The size of pieces of the torrent contents. \"\"\" filelist , size = _dir_files_sizes ( path ) piece_length = get_piece_length ( size ) return ( filelist , size , piece_length )","title":"path_stat()"},{"location":"api/#torrentfile.utils.sortfiles","text":"Generate files one at a time in sorted order. Parameters: Name Type Description Default path(`str`) Directory path to get file list from. required Yields: ( str ) Next path in filelist. Source code in torrentfile\\utils.py def sortfiles ( path ): \"\"\" Generate files one at a time in sorted order. Args: path(`str`): Directory path to get file list from. Yields: (`str`) Next path in filelist. \"\"\" filelist = sorted ( os . listdir ( path ), key = str . lower ) for item in filelist : yield ( item , os . path . join ( path , item )) Torrentfile testing modules.","title":"sortfiles()"},{"location":"api/#tests.context","text":"Context Functions used throughout testing suite.","title":"context"},{"location":"api/#tests.context.fill_file","text":"Fill file with random bytes. Source code in tests\\context.py def fill_file ( path , exp ): \"\"\"Fill file with random bytes.\"\"\" bits = seq () . encode ( \"utf8\" ) bitlen = len ( bits ) filesize = 0 with open ( path , \"wb\" ) as fd : while filesize + bitlen < 2 ** exp : fd . write ( bits ) filesize += bitlen diff = 2 ** exp - filesize fd . write ( bits [: diff + 1 ])","title":"fill_file()"},{"location":"api/#tests.context.fill_folder","text":"Fill temporary folder with meaningless data. Source code in tests\\context.py def fill_folder ( folder ): \"\"\"Fill temporary folder with meaningless data.\"\"\" files = { \"file1.bin\" : 25 , \"file2.bin\" : 26 } if not os . path . exists ( folder ): os . mkdir ( folder ) for k , v in files . items (): path = os . path . join ( folder , k ) fill_file ( path , v )","title":"fill_folder()"},{"location":"api/#tests.context.rmpath","text":"Recursively remove path. Source code in tests\\context.py def rmpath ( path ): \"\"\"Recursively remove path.\"\"\" if not os . path . exists ( path ): return if os . path . isdir ( path ): shutil . rmtree ( path ) else : os . remove ( path )","title":"rmpath()"},{"location":"api/#tests.context.rmpaths","text":"Recursively remove all paths. Source code in tests\\context.py def rmpaths ( paths ): \"\"\"Recursively remove all paths.\"\"\" for path in paths : rmpath ( path )","title":"rmpaths()"},{"location":"api/#tests.context.seq","text":"Generate random sequence of characters. Source code in tests\\context.py def seq (): \"\"\"Generate random sequence of characters.\"\"\" text = string . printable + string . punctuation + string . hexdigits random . shuffle ( list ( text )) return \"\" . join ( text )","title":"seq()"},{"location":"api/#tests.context.sizedfile","text":"Generate a specifically sized file with meaningless data. Source code in tests\\context.py def sizedfile ( num = 28 ): \"\"\"Generate a specifically sized file with meaningless data.\"\"\" path = os . path . join ( TD , \"tempfile.bin\" ) fill_file ( path , num ) return path","title":"sizedfile()"},{"location":"api/#tests.context.tempdir","text":"Generate temporary directory filled with meaningless data. Source code in tests\\context.py def tempdir (): \"\"\"Generate temporary directory filled with meaningless data.\"\"\" tdir = os . path . join ( TD , \"tempdir\" ) tdir_1 = os . path . join ( tdir , \"directory1\" ) for folder in [ tdir , tdir_1 ]: rmpath ( folder ) os . mkdir ( folder ) fill_folder ( folder ) return tdir","title":"tempdir()"},{"location":"api/#tests.context.tempfile","text":"Generate temporary file filled with meaningless data. Source code in tests\\context.py def tempfile (): \"\"\"Generate temporary file filled with meaningless data.\"\"\" path = os . path . join ( TD , \"tempfile.bin\" ) fill_file ( path , 28 ) return path","title":"tempfile()"},{"location":"api/#tests.test_cli","text":"Test CLI script functionality.","title":"test_cli"},{"location":"api/#tests.test_cli.tdir","text":"Generate temp testing directory. Source code in tests\\test_cli.py @pytest . fixture ( scope = \"module\" ) def tdir (): \"\"\"Generate temp testing directory.\"\"\" directory = tempdir () yield directory rmpath ( directory )","title":"tdir()"},{"location":"api/#tests.test_cli.test_cli_args_dir","text":"Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_dir ( tdir ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"--path\" , tdir ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile )","title":"test_cli_args_dir()"},{"location":"api/#tests.test_cli.test_cli_args_dir_v2","text":"Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_dir_v2 ( tdir ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"-p\" , tdir , \"--meta-version\" , \"2\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile )","title":"test_cli_args_dir_v2()"},{"location":"api/#tests.test_cli.test_cli_args_dir_v3","text":"Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_dir_v3 ( tdir ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"-p\" , tdir , \"--meta-version\" , \"3\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile )","title":"test_cli_args_dir_v3()"},{"location":"api/#tests.test_cli.test_cli_args_file","text":"Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_file ( tfile ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"--path\" , tfile ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile )","title":"test_cli_args_file()"},{"location":"api/#tests.test_cli.test_cli_args_file_v2","text":"Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_file_v2 ( tfile ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"-p\" , tfile , \"--meta-version\" , \"2\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile )","title":"test_cli_args_file_v2()"},{"location":"api/#tests.test_cli.test_cli_args_file_v3","text":"Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_args_file_v3 ( tfile ): \"\"\"Test CLI script with specific arguments.\"\"\" args = [ \"-p\" , tfile , \"--meta-version\" , \"3\" ] sys . argv = [ sys . argv [ 0 ]] + args parser = main () assert os . path . exists ( parser . outfile ) # nosec os . remove ( parser . outfile )","title":"test_cli_args_file_v3()"},{"location":"api/#tests.test_cli.test_cli_no_args","text":"Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_no_args (): \"\"\"Test CLI script with specific arguments.\"\"\" sys . argv = [ sys . argv [ 0 ]] try : main () except SystemExit : assert True # nosec","title":"test_cli_no_args()"},{"location":"api/#tests.test_cli.test_cli_no_args_v2","text":"Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_no_args_v2 (): \"\"\"Test CLI script with specific arguments.\"\"\" try : args = [ \"--meta-version\" , \"2\" ] sys . argv = [ sys . argv [ 0 ]] + args assert main () # nosec except MissingPathError : assert True # nosec","title":"test_cli_no_args_v2()"},{"location":"api/#tests.test_cli.test_cli_with_all_args_dir","text":"Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_with_all_args_dir ( tdir ): \"\"\"Test CLI script with specific arguments.\"\"\" sys . argv = [ \"torrentfile\" , \"-p\" , tdir , \"--meta-version\" , \"3\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 14 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main () assert os . path . exists ( parser . outfile ) # nosec","title":"test_cli_with_all_args_dir()"},{"location":"api/#tests.test_cli.test_cli_with_all_args_file","text":"Test CLI script with specific arguments. Source code in tests\\test_cli.py def test_cli_with_all_args_file ( tfile ): \"\"\"Test CLI script with specific arguments.\"\"\" sys . argv = [ \"torrentfile\" , \"-p\" , tfile , \"--meta-version\" , \"2\" , \"-a\" , \"https://tracker-url.com/announce\" , \"--comment\" , \"some comment\" , \"--piece-length\" , str ( 2 ** 14 ), \"--private\" , \"--source\" , \"TRACKER\" , ] parser = main () assert os . path . exists ( parser . outfile ) # nosec","title":"test_cli_with_all_args_file()"},{"location":"api/#tests.test_cli.tfile","text":"Generate temp testing file. Source code in tests\\test_cli.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Generate temp testing file.\"\"\" temp = tempfile () yield temp rmpath ( temp )","title":"tfile()"},{"location":"api/#tests.test_context","text":"Testing operation and coverage for context module in tests directory.","title":"test_context"},{"location":"api/#tests.test_context.test_fill_file","text":"Test fill_file function. Source code in tests\\test_context.py def test_fill_file (): \"\"\"Test fill_file function.\"\"\" path = os . path . join ( TD , \"filledfile.bin\" ) fill_file ( path , 16 ) assert os . path . exists ( path ) # nosec assert os . path . getsize ( path ) >= 2 ** 16 # nosec rmpath ( path )","title":"test_fill_file()"},{"location":"api/#tests.test_context.test_fill_folder","text":"Test fill_folder function. Source code in tests\\test_context.py def test_fill_folder (): \"\"\"Test fill_folder function.\"\"\" folder = os . path . join ( TD , \"filledfolder\" ) fill_folder ( folder ) assert os . path . exists ( folder ) # nosec rmpath ( folder )","title":"test_fill_folder()"},{"location":"api/#tests.test_context.test_rmpath_rmpaths","text":"Test rmpath function and rmpaths function. Source code in tests\\test_context.py @pytest . mark . last def test_rmpath_rmpaths (): \"\"\"Test rmpath function and rmpaths function.\"\"\" dirpath = tempdir () filepath = tempfile () sizedpath = sizedfile ( 16 ) fillfile = os . path . join ( TD , \"filledfile.bin\" ) fillfolder = os . path . join ( TD , \"filledfolder\" ) fill_file ( fillfile , 16 ) fill_folder ( fillfolder ) rmpath ( fillfile ) assert not os . path . exists ( fillfile ) # nosec pathlist = [ sizedpath , dirpath , filepath , fillfolder ] rmpaths ( pathlist ) for path in pathlist : assert not os . path . exists ( path ) # nosec","title":"test_rmpath_rmpaths()"},{"location":"api/#tests.test_context.test_seq","text":"Test seq function for random string output. Source code in tests\\test_context.py def test_seq (): \"\"\"Test seq function for random string output.\"\"\" output = seq () assert len ([ i for i in output if i in string . printable ]) > 1 # nosec","title":"test_seq()"},{"location":"api/#tests.test_context.test_sizedfile","text":"Test tempdir function. Source code in tests\\test_context.py def test_sizedfile (): \"\"\"Test tempdir function.\"\"\" path = sizedfile ( 16 ) assert os . path . exists ( path ) # nosec assert os . path . getsize ( path ) > 2 ** 16 # nosec rmpath ( path )","title":"test_sizedfile()"},{"location":"api/#tests.test_context.test_tempdir","text":"Test tempdir function. Source code in tests\\test_context.py def test_tempdir (): \"\"\"Test tempdir function.\"\"\" dirpath = tempdir () assert os . path . exists ( dirpath ) # nosec rmpath ( dirpath )","title":"test_tempdir()"},{"location":"api/#tests.test_context.test_tempfile","text":"Test tempfile function. Source code in tests\\test_context.py def test_tempfile (): \"\"\"Test tempfile function.\"\"\" filepath = tempfile () assert os . path . exists ( filepath ) # nosec rmpath ( filepath )","title":"test_tempfile()"},{"location":"api/#tests.test_main","text":"Test main module functionality.","title":"test_main"},{"location":"api/#tests.test_main.test_class_annlist_v2","text":"Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : ( \"https://tracker2/announce\" \" https://tracker3/announce\" \" https://tracker4/announce\" ), } torfile = TorrentFileV2 ( ** kwargs ) meta = torfile . assemble () url = \"https://tracker2/announce\" assert url in meta [ \"info\" ][ \"announce list\" ] # nosec","title":"test_class_annlist_v2()"},{"location":"api/#tests.test_main.test_class_list_annlist","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : [ \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torfile = TorrentFile ( ** kwargs ) meta = torfile . assemble () url = \"https://tracker2/announce\" assert url in meta [ \"info\" ][ \"announce list\" ] # nosec","title":"test_class_list_annlist()"},{"location":"api/#tests.test_main.test_class_list_annlist_v2","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_list_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : [ \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ], } torfile = TorrentFileV2 ( ** kwargs ) meta = torfile . assemble () url = \"https://tracker2/announce\" assert url in meta [ \"info\" ][ \"announce list\" ] # nosec","title":"test_class_list_annlist_v2()"},{"location":"api/#tests.test_main.test_class_tuple_annlist","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : ( \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torfile = TorrentFile ( ** kwargs ) meta = torfile . assemble () url = \"https://tracker2/announce\" assert url in meta [ \"info\" ][ \"announce list\" ] # nosec","title":"test_class_tuple_annlist()"},{"location":"api/#tests.test_main.test_class_tuple_annlist_v2","text":"Test TorrentFile Class with tuple announce list arguement. Source code in tests\\test_main.py def test_class_tuple_annlist_v2 ( tfile ): \"\"\"Test TorrentFile Class with tuple announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : ( \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ), } torfile = TorrentFileV2 ( ** kwargs ) meta = torfile . assemble () url = \"https://tracker2/announce\" assert url in meta [ \"info\" ][ \"announce list\" ] # nosec","title":"test_class_tuple_annlist_v2()"},{"location":"api/#tests.test_main.test_class_with_annlist","text":"Test TorrentFile Class with announce list arguement. Source code in tests\\test_main.py def test_class_with_annlist ( tfile ): \"\"\"Test TorrentFile Class with announce list arguement.\"\"\" _ , path = tfile kwargs = { \"announce\" : \"https://tracker1.to/announce\" , \"path\" : path , \"announce_list\" : ( \"https://tracker2/announce\" \" https://tracker3/announce\" \" https://tracker4/announce\" ), } torrent = TorrentFile ( ** kwargs ) url = \"https://tracker2/announce\" assert url in torrent . meta [ \"info\" ][ \"announce list\" ] # nosec","title":"test_class_with_annlist()"},{"location":"api/#tests.test_main.test_main","text":"Test maine . Source code in tests\\test_main.py def test_main (): \"\"\"Test __maine__.\"\"\" assert entry . __doc__ # nosec","title":"test_main()"},{"location":"api/#tests.test_main.test_main_annlist_single","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_single()"},{"location":"api/#tests.test_main.test_main_annlist_single_v1","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v1 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"--meta-version\" , \"1\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_single_v1()"},{"location":"api/#tests.test_main.test_main_annlist_single_v2","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"--meta-version\" , \"2\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_single_v2()"},{"location":"api/#tests.test_main.test_main_annlist_single_v3","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_single_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"--meta-version\" , \"3\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_single_v3()"},{"location":"api/#tests.test_main.test_main_annlist_v2","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v2 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"2\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_v2()"},{"location":"api/#tests.test_main.test_main_annlist_v3","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_annlist_v3 ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , \"--meta-version\" , \"3\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile )","title":"test_main_annlist_v3()"},{"location":"api/#tests.test_main.test_main_announce_list","text":"Test main function with announce list flag. Source code in tests\\test_main.py def test_main_announce_list ( tfile ): \"\"\"Test main function with announce list flag.\"\"\" args , path = tfile sys . argv = args + [ \"--path\" , path , \"--announce-list\" , \"https://tracker2/announce\" , \"https://tracker3/announce\" , \"https://tracker4/announce\" , ] parser = main () url = \"https://tracker2/announce\" assert url in parser . meta [ \"info\" ][ \"announce list\" ] # nosec rmpath ( parser . outfile )","title":"test_main_announce_list()"},{"location":"api/#tests.test_main.tfile","text":"Create fixture for tests. Source code in tests\\test_main.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Create fixture for tests.\"\"\" args = [ \"torrentfile\" , \"--private\" , \"--announce\" , \"https://tracker1.to/announce\" , \"--source\" , \"TFile\" , ] t_file = tempfile () yield args , t_file rmpath ( t_file )","title":"tfile()"},{"location":"api/#tests.test_meta","text":"Test metafile generators functionality.","title":"test_meta"},{"location":"api/#tests.test_meta.maketorrent","text":"Torrent making factory. Source code in tests\\test_meta.py def maketorrent ( args , ver2 = False ): \"\"\"Torrent making factory.\"\"\" if ver2 : torrent = TorrentFileV2 ( ** args ) else : torrent = TorrentFile ( ** args ) torrent . assemble () return torrent . write ()","title":"maketorrent()"},{"location":"api/#tests.test_meta.metav1d","text":"Return generated metadata v1 for directory. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def metav1d ( tdir ): \"\"\"Return generated metadata v1 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args ) yield outfile , meta rmpaths ([ tdir , outfile ])","title":"metav1d()"},{"location":"api/#tests.test_meta.metav1f","text":"Return generated metadata v1 for file. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def metav1f ( tfile ): \"\"\"Return generated metadata v1 for file.\"\"\" args = { \"private\" : True , \"path\" : tfile , \"announce\" : \"http://announce.com/announce\" , } outfile , meta = maketorrent ( args ) yield outfile , meta rmpaths ([ tfile , outfile ])","title":"metav1f()"},{"location":"api/#tests.test_meta.metav2d","text":"Return generated metadata v2 for directory. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def metav2d ( tdir ): \"\"\"Return generated metadata v2 for directory.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , \"source\" : \"tracker\" , \"comment\" : \"content details and purpose\" , } outfile , meta = maketorrent ( args , ver2 = True ) yield outfile , meta rmpaths ([ tdir , outfile ])","title":"metav2d()"},{"location":"api/#tests.test_meta.metav2f","text":"Return generated metadata v2 for file. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def metav2f ( tfile ): \"\"\"Return generated metadata v2 for file.\"\"\" args = { \"private\" : True , \"path\" : tfile , \"announce\" : \"http://announce.com/announce\" , } outfile , meta = maketorrent ( args , ver2 = True ) yield outfile , meta rmpaths ([ tfile , outfile ])","title":"metav2f()"},{"location":"api/#tests.test_meta.tdir","text":"Return temp directory. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def tdir (): \"\"\"Return temp directory.\"\"\" return tempdir ()","title":"tdir()"},{"location":"api/#tests.test_meta.tdirmeta","text":"Test metadata. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def tdirmeta ( tdir ): \"\"\"Test metadata.\"\"\" args = { \"private\" : True , \"path\" : tdir , \"announce\" : \"http://announce.com/announce\" , } outfile , _ = maketorrent ( args ) yield outfile , tdir rmpaths ([ tdir , outfile ])","title":"tdirmeta()"},{"location":"api/#tests.test_meta.test_metafile_checker_v1_dir","text":"Test metadata. Source code in tests\\test_meta.py def test_metafile_checker_v1_dir ( tdirmeta ): \"\"\"Test metadata.\"\"\" outfile , tdir = tdirmeta checker = Checker ( outfile , tdir ) status = checker . check () assert status == \"100%\" # nosec","title":"test_metafile_checker_v1_dir()"},{"location":"api/#tests.test_meta.test_metafile_checker_v1_file","text":"Test metadata. Source code in tests\\test_meta.py def test_metafile_checker_v1_file ( tfilemeta ): \"\"\"Test metadata.\"\"\" outfile , tfile = tfilemeta checker = Checker ( outfile , tfile ) status = checker . check () assert status == \"100%\" # nosec","title":"test_metafile_checker_v1_file()"},{"location":"api/#tests.test_meta.test_v1_info_keys_dir","text":"Test metadata. Source code in tests\\test_meta.py def test_v1_info_keys_dir ( metav1d ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1d for key in [ \"piece length\" , \"pieces\" , \"name\" , \"private\" , \"source\" , \"comment\" , ]: assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v1_info_keys_dir()"},{"location":"api/#tests.test_meta.test_v1_info_keys_file","text":"Test metadata. Source code in tests\\test_meta.py def test_v1_info_keys_file ( metav1f ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1f for key in [ \"length\" , \"piece length\" , \"pieces\" , \"name\" , \"private\" , ]: assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v1_info_keys_file()"},{"location":"api/#tests.test_meta.test_v1_meta_keys","text":"Test metadata. Source code in tests\\test_meta.py def test_v1_meta_keys ( metav1f ): \"\"\"Test metadata.\"\"\" outfile , meta = metav1f for key in [ \"announce\" , \"info\" , \"creation date\" ]: assert key in meta # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v1_meta_keys()"},{"location":"api/#tests.test_meta.test_v2_info_keys_dir","text":"Test metadata. Source code in tests\\test_meta.py def test_v2_info_keys_dir ( metav2d ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2d for key in [ \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , \"source\" , \"comment\" , ]: assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v2_info_keys_dir()"},{"location":"api/#tests.test_meta.test_v2_info_keys_file","text":"Test metadata. Source code in tests\\test_meta.py def test_v2_info_keys_file ( metav2f ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2f for key in [ \"length\" , \"piece length\" , \"meta version\" , \"file tree\" , \"name\" , \"private\" , ]: assert key in meta [ \"info\" ] # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v2_info_keys_file()"},{"location":"api/#tests.test_meta.test_v2_meta_keys","text":"Test metadata. Source code in tests\\test_meta.py def test_v2_meta_keys ( metav2f ): \"\"\"Test metadata.\"\"\" outfile , meta = metav2f for key in [ \"announce\" , \"info\" , \"piece layers\" , \"creation date\" ]: assert key in meta # nosec assert os . path . exists ( outfile ) # nosec","title":"test_v2_meta_keys()"},{"location":"api/#tests.test_meta.tfile","text":"Return temp file. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Return temp file.\"\"\" return tempfile ()","title":"tfile()"},{"location":"api/#tests.test_meta.tfilemeta","text":"Test metadata. Source code in tests\\test_meta.py @pytest . fixture ( scope = \"module\" ) def tfilemeta ( tfile ): \"\"\"Test metadata.\"\"\" args = { \"private\" : True , \"path\" : tfile , \"announce\" : \"http://announce.com/announce\" , } outfile , _ = maketorrent ( args ) yield outfile , tfile rmpaths ([ tfile , outfile ])","title":"tfilemeta()"},{"location":"api/#tests.test_torrentfile","text":"Testing functions for torrentfile module.","title":"test_torrentfile"},{"location":"api/#tests.test_torrentfile.tdir","text":"Return temporary directory. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def tdir (): \"\"\"Return temporary directory.\"\"\" folder = tempdir () args = { \"path\" : folder , \"announce\" : \"https://tracker.com/announce\" } yield ( folder , args ) rmpath ( folder )","title":"tdir()"},{"location":"api/#tests.test_torrentfile.test_exception_decoding_error","text":"Test temporary dir decoding with arguments. Source code in tests\\test_torrentfile.py def test_exception_decoding_error (): \"\"\"Test temporary dir decoding with arguments.\"\"\" try : val = b \"i:alphabet\" decoder = utils . Bendecoder () val = decoder . decode ( val ) assert False # nosec except exceptions . BendecodingError : assert True # nosec","title":"test_exception_decoding_error()"},{"location":"api/#tests.test_torrentfile.test_exception_encoding_error","text":"Test temporary dir encoding with arguments. Source code in tests\\test_torrentfile.py def test_exception_encoding_error (): \"\"\"Test temporary dir encoding with arguments.\"\"\" try : val = set ([ 1 , 2 , 3 , 4 , 5 ]) encoder = utils . Benencoder () val = encoder . encode ( val ) assert False # nosec except exceptions . BenencodingError : assert True # nosec","title":"test_exception_encoding_error()"},{"location":"api/#tests.test_torrentfile.test_exception_path_error","text":"Test MissingPathError exception. Source code in tests\\test_torrentfile.py def test_exception_path_error (): \"\"\"Test MissingPathError exception.\"\"\" try : raise exceptions . MissingPathError ( \"this is a message\" ) except exceptions . MissingPathError : assert True # nosec","title":"test_exception_path_error()"},{"location":"api/#tests.test_torrentfile.test_torrentfile_dir","text":"Test temporary directory. Source code in tests\\test_torrentfile.py def test_torrentfile_dir ( tdir ): \"\"\"Test temporary directory.\"\"\" _ , args = tdir torrent = TorrentFile ( ** args ) data = torrent . assemble () assert data is not None # nosec","title":"test_torrentfile_dir()"},{"location":"api/#tests.test_torrentfile.test_torrentfile_dir_comment","text":"Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_comment ( tdir ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir args [ \"private\" ] = True args [ \"comment\" ] = \"This is a comment\" torrent = TorrentFile ( ** args ) data = torrent . assemble () assert \"private\" in data [ \"info\" ] and \"comment\" in data [ \"info\" ] # nosec","title":"test_torrentfile_dir_comment()"},{"location":"api/#tests.test_torrentfile.test_torrentfile_dir_private","text":"Test temporary dir with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_dir_private ( tdir ): \"\"\"Test temporary dir with arguments.\"\"\" _ , args = tdir args [ \"private\" ] = True torrent = TorrentFile ( ** args ) data = torrent . assemble () assert \"private\" in data [ \"info\" ] # nosec","title":"test_torrentfile_dir_private()"},{"location":"api/#tests.test_torrentfile.test_torrentfile_file","text":"Test temporary file. Source code in tests\\test_torrentfile.py def test_torrentfile_file ( tfile ): \"\"\"Test temporary file.\"\"\" _ , args = tfile torrent = TorrentFile ( ** args ) data = torrent . assemble () assert data is not None # nosec","title":"test_torrentfile_file()"},{"location":"api/#tests.test_torrentfile.test_torrentfile_file_comment","text":"Test temporary file with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_file_comment ( tfile ): \"\"\"Test temporary file with arguments.\"\"\" _ , args = tfile args [ \"private\" ] = True args [ \"comment\" ] = \"This is a comment\" torrent = TorrentFile ( ** args ) data = torrent . assemble () assert \"private\" in data [ \"info\" ] and \"comment\" in data [ \"info\" ] # nosec","title":"test_torrentfile_file_comment()"},{"location":"api/#tests.test_torrentfile.test_torrentfile_file_private","text":"Test temporary file with arguments. Source code in tests\\test_torrentfile.py def test_torrentfile_file_private ( tfile ): \"\"\"Test temporary file with arguments.\"\"\" _ , args = tfile args [ \"private\" ] = True torrent = TorrentFile ( ** args ) data = torrent . assemble () assert \"private\" in data [ \"info\" ] # nosec","title":"test_torrentfile_file_private()"},{"location":"api/#tests.test_torrentfile.tfile","text":"Return temporary file. Source code in tests\\test_torrentfile.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Return temporary file.\"\"\" fd = tempfile () args = { \"path\" : fd , \"announce\" : \"https://tracker.com/announce\" } yield ( fd , args ) rmpath ( fd )","title":"tfile()"},{"location":"api/#tests.test_utils","text":"Test functions for utils module.","title":"test_utils"},{"location":"api/#tests.test_utils.bencode","text":"Test encoding in bencode format. Source code in tests\\test_utils.py @pytest . fixture def bencode ( metadata ): \"\"\"Test encoding in bencode format.\"\"\" encoder = Benencoder ( metadata ) data = encoder . encode () return data","title":"bencode()"},{"location":"api/#tests.test_utils.metadata","text":"Return preconfigured metadata. Source code in tests\\test_utils.py @pytest . fixture def metadata (): \"\"\"Return preconfigured metadata.\"\"\" meta = { \"announce\" : \"https://tracker.com:2017/announce\" , \"created by\" : \"torrentfile\" , \"piece length\" : MAX_BLOCK , \"info\" : { \"name\" : \"torrentname.bin\" , \"files\" : [ { \"length\" : 2 ** 28 , \"path\" : [ \"path\" , \"to\" , \"content\" ]}, { \"length\" : 2 ** 28 , \"path\" : [ \"path\" , \"more\" , \"content\" ]}, ], \"pieces\" : b \"some bytes of data\" , \"source\" : \"tracker\" , \"private\" : 1 , }, } return meta","title":"metadata()"},{"location":"api/#tests.test_utils.tdir","text":"Return temporary directory. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" ) def tdir (): \"\"\"Return temporary directory.\"\"\" drct = tempdir () yield drct rmpath ( drct )","title":"tdir()"},{"location":"api/#tests.test_utils.test_decode","text":"Test Bendecoder. Source code in tests\\test_utils.py def test_decode ( bencode ): \"\"\"Test Bendecoder.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert data is not None # nosec","title":"test_decode()"},{"location":"api/#tests.test_utils.test_decode_type","text":"Test Bendecoder output type. Source code in tests\\test_utils.py def test_decode_type ( bencode ): \"\"\"Test Bendecoder output type.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert isinstance ( data , dict ) # nosec","title":"test_decode_type()"},{"location":"api/#tests.test_utils.test_decode_type_announce","text":"Test Benencoder output contents. Source code in tests\\test_utils.py def test_decode_type_announce ( bencode ): \"\"\"Test Benencoder output contents.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert \"announce\" in data # nosec","title":"test_decode_type_announce()"},{"location":"api/#tests.test_utils.test_decode_type_created_by","text":"Test Bendecoder output type. Source code in tests\\test_utils.py def test_decode_type_created_by ( bencode ): \"\"\"Test Bendecoder output type.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert \"created by\" in data # nosec","title":"test_decode_type_created_by()"},{"location":"api/#tests.test_utils.test_decode_type_info","text":"Test Benencoder output contents type. Source code in tests\\test_utils.py def test_decode_type_info ( bencode ): \"\"\"Test Benencoder output contents type.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert \"info\" in data # nosec","title":"test_decode_type_info()"},{"location":"api/#tests.test_utils.test_decode_type_piecelength","text":"Test Bendecoder output contents. Source code in tests\\test_utils.py def test_decode_type_piecelength ( bencode ): \"\"\"Test Bendecoder output contents.\"\"\" decoder = Bendecoder ( bencode ) data = decoder . decode () assert \"piece length\" in data # nosec","title":"test_decode_type_piecelength()"},{"location":"api/#tests.test_utils.test_encode","text":"Test Benencoder. Source code in tests\\test_utils.py def test_encode ( metadata ): \"\"\"Test Benencoder.\"\"\" encoder = Benencoder ( metadata ) data = encoder . encode () assert data is not None # nosec","title":"test_encode()"},{"location":"api/#tests.test_utils.test_encode_type","text":"Test Benencoder output type. Source code in tests\\test_utils.py def test_encode_type ( metadata ): \"\"\"Test Benencoder output type.\"\"\" encoder = Benencoder ( metadata ) data = encoder . encode () assert isinstance ( data , bytes ) # nosec","title":"test_encode_type()"},{"location":"api/#tests.test_utils.test_get_file_list_dir","text":"Test get_file_list function for tempdir. Source code in tests\\test_utils.py def test_get_file_list_dir ( tdir ): \"\"\"Test get_file_list function for tempdir.\"\"\" results = get_file_list ( tdir ) assert len ( results ) > 1 # nosec","title":"test_get_file_list_dir()"},{"location":"api/#tests.test_utils.test_get_file_list_dir_sort","text":"Test get_file_list function for tempdir sorted. Source code in tests\\test_utils.py def test_get_file_list_dir_sort ( tdir ): \"\"\"Test get_file_list function for tempdir sorted.\"\"\" results = get_file_list ( tdir , sort = True ) assert len ( results ) > 1 # nosec","title":"test_get_file_list_dir_sort()"},{"location":"api/#tests.test_utils.test_get_file_list_file","text":"Test get_file_list function for tempfile. Source code in tests\\test_utils.py def test_get_file_list_file ( tfile ): \"\"\"Test get_file_list function for tempfile.\"\"\" results = get_file_list ( tfile ) assert len ( results ) == 1 # nosec","title":"test_get_file_list_file()"},{"location":"api/#tests.test_utils.test_get_piece_len","text":"Test get_piece_length function does not exceed max. Source code in tests\\test_utils.py def test_get_piece_len ( tfile ): \"\"\"Test get_piece_length function does not exceed max.\"\"\" size = os . path . getsize ( tfile ) result = get_piece_length ( size ) assert result <= MAX_BLOCK # nosec","title":"test_get_piece_len()"},{"location":"api/#tests.test_utils.test_get_piece_len_large","text":"Test get_piece_length function does not exceed maximum. Source code in tests\\test_utils.py def test_get_piece_len_large (): \"\"\"Test get_piece_length function does not exceed maximum.\"\"\" size = 2 ** 31 result = get_piece_length ( size ) assert result <= MAX_BLOCK # nosec","title":"test_get_piece_len_large()"},{"location":"api/#tests.test_utils.test_get_piece_len_power_2","text":"Test get_piece_length function is a power of 2. Source code in tests\\test_utils.py def test_get_piece_len_power_2 ( tfile ): \"\"\"Test get_piece_length function is a power of 2.\"\"\" size = os . path . getsize ( tfile ) result = get_piece_length ( size ) assert result % MIN_BLOCK == 0 # nosec","title":"test_get_piece_len_power_2()"},{"location":"api/#tests.test_utils.test_get_piece_length_min","text":"Test get_piece_length function does not fall under minimum. Source code in tests\\test_utils.py def test_get_piece_length_min ( tfile ): \"\"\"Test get_piece_length function does not fall under minimum.\"\"\" size = os . path . getsize ( tfile ) result = get_piece_length ( size ) assert result >= MIN_BLOCK # nosec","title":"test_get_piece_length_min()"},{"location":"api/#tests.test_utils.test_path_piece_length_max","text":"Test path_piece_length for dir return piece_length < Maximum. Source code in tests\\test_utils.py def test_path_piece_length_max ( tdir ): \"\"\"Test path_piece_length for dir return piece_length < Maximum.\"\"\" result = path_piece_length ( tdir ) assert result <= MAX_BLOCK # nosec","title":"test_path_piece_length_max()"},{"location":"api/#tests.test_utils.test_path_piece_length_min","text":"Test path_piece_length for dir return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_min ( tdir ): \"\"\"Test path_piece_length for dir return piece_length is power of 2.\"\"\" result = path_piece_length ( tdir ) assert result >= MIN_BLOCK # nosec","title":"test_path_piece_length_min()"},{"location":"api/#tests.test_utils.test_path_piece_length_pow2","text":"Test path_piece_length for file return piece_length is power of 2. Source code in tests\\test_utils.py def test_path_piece_length_pow2 ( tdir ): \"\"\"Test path_piece_length for file return piece_length is power of 2.\"\"\" result = path_piece_length ( tdir ) assert result % MIN_BLOCK == 0 # nosec","title":"test_path_piece_length_pow2()"},{"location":"api/#tests.test_utils.test_path_size_file","text":"Test path_size function for tempfile. Source code in tests\\test_utils.py def test_path_size_file ( tfile ): \"\"\"Test path_size function for tempfile.\"\"\" size = os . path . getsize ( tfile ) val = path_size ( tfile ) assert size == val # nosec","title":"test_path_size_file()"},{"location":"api/#tests.test_utils.test_path_size_file_gt0","text":"Test path_size function for tempfile is greater than zero. Source code in tests\\test_utils.py def test_path_size_file_gt0 ( tfile ): \"\"\"Test path_size function for tempfile is greater than zero.\"\"\" val = path_size ( tfile ) assert val > 0 # nosec","title":"test_path_size_file_gt0()"},{"location":"api/#tests.test_utils.test_path_stat_base2_plen","text":"Test path_stat function return piece length is power of 2. Source code in tests\\test_utils.py def test_path_stat_base2_plen ( tdir ): \"\"\"Test path_stat function return piece length is power of 2.\"\"\" _ , _ , piece_length = path_stat ( tdir ) assert piece_length % MIN_BLOCK == 0 # nosec","title":"test_path_stat_base2_plen()"},{"location":"api/#tests.test_utils.test_path_stat_eq_filelist","text":"Test path_stat function return filelist. Source code in tests\\test_utils.py def test_path_stat_eq_filelist ( tdir ): \"\"\"Test path_stat function return filelist.\"\"\" filelist , _ , _ = path_stat ( tdir ) assert len ( filelist ) > 1 # nosec","title":"test_path_stat_eq_filelist()"},{"location":"api/#tests.test_utils.test_path_stat_eq_size","text":"Test path_stat function return identically correct size. Source code in tests\\test_utils.py def test_path_stat_eq_size ( tdir ): \"\"\"Test path_stat function return identically correct size.\"\"\" filelist , size , _ = path_stat ( tdir ) assert size == sum ([ os . path . getsize ( x ) for x in filelist ]) # nosec","title":"test_path_stat_eq_size()"},{"location":"api/#tests.test_utils.test_path_stat_gt0_filelist","text":"Test path_stat function for tempdir sorted > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_filelist ( tdir ): \"\"\"Test path_stat function for tempdir sorted > 0.\"\"\" filelist , _ , _ = path_stat ( tdir ) assert len ( filelist ) > 0 # nosec","title":"test_path_stat_gt0_filelist()"},{"location":"api/#tests.test_utils.test_path_stat_gt0_plen","text":"Test path_stat function return piece length > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_plen ( tdir ): \"\"\"Test path_stat function return piece length > 0.\"\"\" _ , _ , piece_length = path_stat ( tdir ) assert piece_length >= MIN_BLOCK # nosec","title":"test_path_stat_gt0_plen()"},{"location":"api/#tests.test_utils.test_path_stat_gt0_size","text":"Test path_stat function return size > 0. Source code in tests\\test_utils.py def test_path_stat_gt0_size ( tdir ): \"\"\"Test path_stat function return size > 0.\"\"\" _ , size , _ = path_stat ( tdir ) assert size > 0 # nosec","title":"test_path_stat_gt0_size()"},{"location":"api/#tests.test_utils.test_path_stat_gtsize_plen","text":"Test path_stat function return size > piece length. Source code in tests\\test_utils.py def test_path_stat_gtsize_plen ( tdir ): \"\"\"Test path_stat function return size > piece length.\"\"\" _ , size , piece_length = path_stat ( tdir ) assert size > piece_length # nosec","title":"test_path_stat_gtsize_plen()"},{"location":"api/#tests.test_utils.tfile","text":"Return temporary file. Source code in tests\\test_utils.py @pytest . fixture ( scope = \"module\" ) def tfile (): \"\"\"Return temporary file.\"\"\" testfile = tempfile () yield testfile rmpath ( testfile )","title":"tfile()"}]}